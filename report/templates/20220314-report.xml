<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="4" failures="24" skipped="33" tests="102" time="496.232" timestamp="2022-03-14T14:33:04.190439" hostname="xushuaideMacBook-Pro.local"><testcase classname="test_cases.contract.client.account.test_get_account_info.Test_get_account_info" name="test_get_account_info[main-获取用户账户信息-success-0-]" time="3.987" /><testcase classname="test_cases.contract.client.account.test_open_thanos.Test_open_thanos" name="test_open_thanos[main-开通合约-success-0-]" time="0.798" /><testcase classname="test_cases.contract.client.collection.test_collection_add.Test_collection_add" name="test_collection_add[main-收藏存在的交易对-btc_usdt-success-0-]" time="4.846" /><testcase classname="test_cases.contract.client.collection.test_collection_cancel.Test_collection_cancel" name="test_collection_cancel[main-取消收藏过的交易对-fil_usdt-success-0-]" time="4.963" /><testcase classname="test_cases.contract.client.collection.test_collection_list.Test_collection_list" name="test_collection_list[main-收藏存在的交易对-success-0-]" time="5.391" /><testcase classname="test_cases.contract.client.fund.test_get_balance_bills.Test_get_balance_bills" name="test_get_balance_coin[main-正确的币种-usdt-NEXT--61e7b401a2fb31166283e085-10----success-0-]" time="32.384"><failure message="pymongo.errors.ConfigurationError: The DNS operation timed out after 21.155035972595215 seconds">self = &lt;pymongo.srv_resolver._SrvResolver object at 0x110e83bb0&gt;

    def get_options(self):
        try:
&gt;           results = _resolve(self.__fqdn, 'TXT',
                               lifetime=self.__connect_timeout)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('cluster0.2ksbi.mongodb.net', 'TXT'), kwargs = {'lifetime': 20.0}

    def _resolve(*args, **kwargs):
        if hasattr(resolver, 'resolve'):
            # dnspython &gt;= 2
&gt;           return resolver.resolve(*args, **kwargs)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

qname = 'cluster0.2ksbi.mongodb.net', rdtype = 'TXT'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True,
                source_port=0, lifetime=None, search=None):
        """Query nameservers to find the answer to the question.
    
        This is a convenience function that uses the default resolver
        object to make the query.
    
        See ``dns.resolver.Resolver.resolve`` for more information on the
        parameters.
        """
    
&gt;       return get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,
                                              raise_on_no_answer, source_port,
                                              lifetime, search)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;
qname = 'cluster0.2ksbi.mongodb.net', rdtype = 'TXT'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True, source_port=0,
                lifetime=None, search=None):  # pylint: disable=arguments-differ
        """Query nameservers to find the answer to the question.
    
        The *qname*, *rdtype*, and *rdclass* parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.
    
        *qname*, a ``dns.name.Name`` or ``str``, the query name.
    
        *rdtype*, an ``int`` or ``str``,  the query type.
    
        *rdclass*, an ``int`` or ``str``,  the query class.
    
        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
    
        *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
        address when making queries.
    
        *raise_on_no_answer*, a ``bool``.  If ``True``, raise
        ``dns.resolver.NoAnswer`` if there's no answer to the question.
    
        *source_port*, an ``int``, the port from which to send the message.
    
        *lifetime*, a ``float``, how many seconds a query should run
         before timing out.
    
        *search*, a ``bool`` or ``None``, determines whether the
        search list configured in the system's resolver configuration
        are used for relative names, and whether the resolver's domain
        may be added to relative names.  The default is ``None``,
        which causes the value of the resolver's
        ``use_search_by_default`` attribute to be used.
    
        Raises ``dns.exception.Timeout`` if no answers could be found
        in the specified lifetime.
    
        Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
    
        Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
        DNAME substitution.
    
        Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
        ``True`` and the query name exists but has no RRset of the
        desired type and class.
    
        Raises ``dns.resolver.NoNameservers`` if no non-broken
        nameservers are available to answer the question.
    
        Returns a ``dns.resolver.Answer`` instance.
    
        """
    
        resolution = _Resolution(self, qname, rdtype, rdclass, tcp,
                                 raise_on_no_answer, search)
        start = time.time()
        while True:
            (request, answer) = resolution.next_request()
            # Note we need to say "if answer is not None" and not just
            # "if answer" because answer implements __len__, and python
            # will call that.  We want to return if we have an answer
            # object, including in cases where its length is 0.
            if answer is not None:
                # cache hit!
                return answer
            done = False
            while not done:
                (nameserver, port, tcp, backoff) = resolution.next_nameserver()
                if backoff:
                    time.sleep(backoff)
&gt;               timeout = self._compute_timeout(start, lifetime)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;, start = 1647239623.500952
lifetime = 20.0

    def _compute_timeout(self, start, lifetime=None):
        lifetime = self.lifetime if lifetime is None else lifetime
        now = time.time()
        duration = now - start
        if duration &lt; 0:
            if duration &lt; -1:
                # Time going backwards is bad.  Just give up.
                raise Timeout(timeout=duration)
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        if duration &gt;= lifetime:
&gt;           raise Timeout(timeout=duration)
E           dns.exception.Timeout: The DNS operation timed out after 21.155035972595215 seconds

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:997: Timeout

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.fund.test_get_balance_bills.Test_get_balance_bills object at 0x110cb2e50&gt;
scene = 'main-正确的币种', coin = 'usdt', direction = 'NEXT', endTime = ''
id = '61e7b401a2fb31166283e085', limit = 10, startTime = '', symbol = ''
type = '', except_result = 'success', except_code = 0, except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,coin,direction,endTime,id,limit,startTime,\
                                symbol,type,except_result,except_code,except_msg",
                             api_balance_bills["get_balance_bills"])
    def test_get_balance_coin(self,scene,coin,direction,endTime,id,limit,startTime,\
                                    symbol,type,except_result,except_code,except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{coin}-{direction}-{endTime}-{id}-{limit}-\
                             {startTime}-{symbol}-{type}-{except_result}\
                                {except_code}-"{except_msg}"')
        curl_accountId = get_account_info().response.get("result").get("accountId")
        args = {
            "col": "balanceBill",
        }
        logger.info("当前用户 accountId 是{}".format(curl_accountId))
         # 根据时间排序，取出最老的一条数据
        if scene.endswith('正确的币种'):
            if MongoDb(args).find_one({"accountId": curl_accountId}) is None:
                res = None
            else:
                # 取当前账户最新的一条数据
&gt;               res = MongoDb(args).descending_sort_find(
                    {"coin": "{}".format(coin.strip()), "accountId": curl_accountId},
                    'createdTime', 1,
                )

test_cases/contract/client/fund/test_get_balance_bills.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/mongodb_operate.py:25: in __init__
    self.client = pymongo.MongoClient(db_conf["url"])
../../Library/Python/3.8/lib/python/site-packages/pymongo/mongo_client.py:670: in __init__
    res = uri_parser.parse_uri(
../../Library/Python/3.8/lib/python/site-packages/pymongo/uri_parser.py:525: in parse_uri
    dns_options = dns_resolver.get_options()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymongo.srv_resolver._SrvResolver object at 0x110e83bb0&gt;

    def get_options(self):
        try:
            results = _resolve(self.__fqdn, 'TXT',
                               lifetime=self.__connect_timeout)
        except (resolver.NoAnswer, resolver.NXDOMAIN):
            # No TXT records
            return None
        except Exception as exc:
&gt;           raise ConfigurationError(str(exc))
E           pymongo.errors.ConfigurationError: The DNS operation timed out after 21.155035972595215 seconds

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:79: ConfigurationError</failure></testcase><testcase classname="test_cases.contract.client.fund.test_get_balance_coin.Test_get_balance_coin" name="test_get_balance_coin[main-获取用户币种资金正常-usdt-success-0-]" time="21.713" /><testcase classname="test_cases.contract.client.fund.test_get_balance_list.Test_get_balance_list" name="test_get_balance_list[scene0-except_result0-except_returnCode0-except_msg0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['scene', 'except_result', 'except_returnCode', 'except_msg'], function test_get_balance_list at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/fund/test_get_balance_list.py:23">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/fund/test_get_balance_list.py:24: got empty parameter set ['scene', 'except_result', 'except_returnCode', 'except_msg'], function test_get_balance_list at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/fund/test_get_balance_list.py:23</skipped></testcase><testcase classname="test_cases.contract.client.leverage_bracket.test_query_everage_bracket.Test_query_leverage_bracket" name="test_query_leverage_bracket[main-正常查询-doge_usdt-success-0-]" time="2.171" /><testcase classname="test_cases.contract.client.leverage_bracket.test_query_everage_bracket_list.Test_query_leverage_bracket_list" name="test_query_leverage_bracket_list[main-正常查询-success-0-]" time="0.901" /><testcase classname="test_cases.contract.client.order.test_cancel_order.TestCancelOrder" name="test_cancel_success[test_data0]" time="1.614"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1111f22e0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x110f56200&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111f2a00&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.order.test_cancel_order.TestCancelOrder object at 0x110eb8c10&gt;
test_data = {'cancel_failed': {}, 'cancel_success': {'cancel_new_order': {'expected_result': {'msgInfo': 'success', 'state': 4}, '...LIMIT', 'origQty': 10, 'positionSide': 'LONG', ...}}}, 'test_create_batch_failed': {}, 'test_create_batch_success': {}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("cancel_success") == {} else [test_data])
    def test_cancel_success(self,test_data):
        order_request = self.order_request
        cases_data = test_data["cancel_success"]
        order_request.mongo.update_col("order")
        for value in cases_data.values():
            # 获取并组装参数
            case_name, parameter, expected_result = value["name"], value["order_parameter"], value["expected_result"]
            if "price" in list(parameter.keys()):
                parameter["price"] = round(self.index_price)
            if "triggerProfitPrice" in list(parameter.keys()):
                # self.index_price + Decimal(0.5)
                parameter["triggerProfitPrice"] = round(self.index_price + Decimal(1))
            if "triggerStopPrice" in list(parameter.keys()):
                parameter["triggerStopPrice"] = round(self.index_price - Decimal(0.5))
            # 下单并从返回结果中获取order_id
            res = order_request.create(parm=parameter)
            logger.info("下单响应结果为{}".format(res))
            order_id = int(res["result"])
            # 根据参数判断是否是撤销部分成交单，如果是部分成交单就用用户2市场价吃到一部分单
            if "taker_order_parameter" in list(value.keys()):
                user2_order = order_request.create(parm=value["taker_order_parameter"], test_user='test_user2')
            # 撤销订单
&gt;           res_cancel = order_request.cancel(order_id=order_id)

test_cases/contract/client/order/test_cancel_order.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/order/order_request.py:26: in cancel
    res = xtthanos_trade_http.cancel(headers=header, params=parm)
api/thanos_http.py:196: in cancel
    return requests(cancel.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.order.test_cancel_order.TestCancelOrder" name="test_cancel_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_cancel_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:57">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:58: got empty parameter set ['test_data'], function test_cancel_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:57</skipped></testcase><testcase classname="test_cases.contract.client.order.test_cancel_order.TestCancelOrder" name="test_create_batch_success[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_create_batch_success at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:79">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:80: got empty parameter set ['test_data'], function test_create_batch_success at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:79</skipped></testcase><testcase classname="test_cases.contract.client.order.test_cancel_order.TestCancelOrder" name="test_create_batch_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_create_batch_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:107">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:108: got empty parameter set ['test_data'], function test_create_batch_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_cancel_order.py:107</skipped></testcase><testcase classname="test_cases.contract.client.order.test_create_batch.TestCreateBatch" name="test_order_success[test_data0]" time="0.338" /><testcase classname="test_cases.contract.client.order.test_create_batch.TestCreateBatch" name="test_order_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_order_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_batch.py:32">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_batch.py:33: got empty parameter set ['test_data'], function test_order_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_batch.py:32</skipped></testcase><testcase classname="test_cases.contract.client.order.test_create_order.TestCreate" name="test_order_success[test_data0]" time="0.006"><failure message="TypeError: Object of type Decimal is not JSON serializable">self = &lt;thanos_test.test_cases.contract.client.order.test_create_order.TestCreate object at 0x1111c4e50&gt;
test_data = {'close_position_order_failed': {}, 'close_position_order_without_position': {}, 'order_failed_parm': {}, 'order_failed_profit': {}, ...}

    @pytest.mark.parametrize("test_data", [] if test_data.get("order_success") == {} else [test_data])
    def test_order_success(self, test_data):
        order_request = self.order_request
        cases_data = test_data["order_success"]
        order_request.mongo.update_col("order")
        profit_dict = {
            "good_than_price": round(Decimal(self.index_price) + Decimal(0.5)),
            "less_than_price": round(Decimal(self.index_price) - Decimal(0.5))
        }
        for value in cases_data.values():
            # 获取并组装参数
            case_name, parameter, expected_result = value["name"], value["parameter"], value["expected_result"]
            if "price" in list(parameter.keys()):
                parameter["price"] = Decimal(self.index_price)
            if "triggerProfitPrice" in list(parameter.keys()):
                parameter["triggerProfitPrice"] = profit_dict.get(parameter.get("triggerProfitPrice"))
            if "triggerStopPrice" in list(parameter.keys()):
                parameter["triggerStopPrice"] = profit_dict.get(parameter.get("triggerStopPrice"))
            # 发起请求，获取结果
&gt;           res = order_request.create(parm=parameter)

test_cases/contract/client/order/test_create_order.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/order/order_request.py:55: in create
    res = xtthanos_trade_http.create(headers=header, params=parm)
api/thanos_http.py:190: in create
    return requests(create.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:37: in request
    self.request_log(url, method, data, json, params, headers, files, cookies)
api/http_api.py:59: in request_log
    logger.info("接口请求 params 参数 ==&gt;&gt; {}".format(complexjson.dumps(params, indent=4, ensure_ascii=False)))
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/json/__init__.py:234: in dumps
    return cls(
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/json/encoder.py:201: in encode
    chunks = list(chunks)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/json/encoder.py:431: in _iterencode
    yield from _iterencode_dict(o, _current_indent_level)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/json/encoder.py:405: in _iterencode_dict
    yield from chunks
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/json/encoder.py:438: in _iterencode
    o = _default(o)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;json.encoder.JSONEncoder object at 0x1110aaa90&gt;, o = Decimal('2.166')

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
&gt;       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type Decimal is not JSON serializable

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/json/encoder.py:179: TypeError</failure></testcase><testcase classname="test_cases.contract.client.order.test_create_order.TestCreate" name="test_order_failed_parm[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_order_failed_parm at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:71">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:72: got empty parameter set ['test_data'], function test_order_failed_parm at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:71</skipped></testcase><testcase classname="test_cases.contract.client.order.test_create_order.TestCreate" name="test_order_failed_profit[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_order_failed_profit at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:91">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:92: got empty parameter set ['test_data'], function test_order_failed_profit at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:91</skipped></testcase><testcase classname="test_cases.contract.client.order.test_create_order.TestCreate" name="test_close_position_order_fail[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_close_position_order_fail at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:117">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:118: got empty parameter set ['test_data'], function test_close_position_order_fail at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:117</skipped></testcase><testcase classname="test_cases.contract.client.order.test_create_order.TestCreate" name="test_close_position_order_without_position[test_data0]" time="0.184"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_close_position_order_without_position at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:137">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:138: got empty parameter set ['test_data'], function test_close_position_order_without_position at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_create_order.py:137</skipped></testcase><testcase classname="test_cases.contract.client.order.test_detail.TestDetail" name="test_detail_success[test_data0]" time="1.614"><failure message="AssertionError: assert 'failure' == 'success'&#10;  - success&#10;  + failure">self = &lt;thanos_test.test_cases.contract.client.order.test_detail.TestDetail object at 0x1110846d0&gt;
test_data = {'detail_failed': {}, 'detail_success': {'correct': {'account_id': 39, 'expected_result': {'msgInfo': 'success'}, 'name': 'main-订单id正确查询', 'parameter': None}}}

    @pytest.mark.parametrize("test_data",  [] if test_data.get("detail_success") == {} else [test_data])
    def test_detail_success(self, test_data):
        order_request = self.order_request
        # 从数据文件获取数据
        case_data = test_data["detail_success"]["correct"]
        case_name = case_data["name"]
        expected_result = case_data["expected_result"]
        # 去mongo获取任意一条订单
        order_request.mongo.update_col("order")
        mongo_res = order_request.mongo.find_one({"accountId": self.order_request.account_id})
        order_id = mongo_res["_id"]
        # 通过订单id获取接口返回数据
        res = order_request.detail(order_id=order_id)
        logger.info(f'订单id查询订单接口---&gt;{case_name}--&gt;参数为{order_id}---&gt;返回结果{res}')
        # 断言，比对数据
&gt;       assert res["msgInfo"] == expected_result["msgInfo"]
E       AssertionError: assert 'failure' == 'success'
E         - success
E         + failure

test_cases/contract/client/order/test_detail.py:36: AssertionError</failure></testcase><testcase classname="test_cases.contract.client.order.test_detail.TestDetail" name="test_detail_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_detail_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_detail.py:43">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_detail.py:44: got empty parameter set ['test_data'], function test_detail_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_detail.py:43</skipped></testcase><testcase classname="test_cases.contract.client.order.test_list.TestOrderList" name="test_list_success[test_data0]" time="0.278"><failure message="KeyError: 'msgInfo'">self = &lt;thanos_test.test_cases.contract.client.order.test_list.TestOrderList object at 0x11100a640&gt;
test_data = {'list_failed': {}, 'list_success': {'all_parameter': {'expected_result': {'msgInfo': 'success'}, 'name': 'main-无参数查询订...e': 10, ...}}, 'no_parameter': {'expected_result': {'msgInfo': 'success'}, 'name': 'main-无参数查询订单', 'parameter': None}}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("list_success") == {} else [test_data])
    def test_list_success(self, test_data):
        order_request = self.order_request
        now_time = get_timestamp_now()
        five_day_ago = before_timestamp_by_day(5)
        case_data = test_data["list_success"]
        order_request.mongo.update_col("order")
        for value in case_data.values():
            # 从文件中读取数据
            case_name, parameter, expected_result = value["name"], value["parameter"], value["expected_result"]
            # 用户1的accountId,修改账户时要修改common_util的account_id
            query = {"accountId": order_request.account_id}
            logger.info(f'查询订单列表接口参数初始值---&gt;{parameter}')
            # 根据参数组装mongo查询条件
            if parameter:
                if "startTime" in list(parameter.keys()) and "endTime" in list(parameter.keys()):
                    parameter["startTime"] = five_day_ago
                    parameter["endTime"] = now_time
                    query["createdTime"] = {"$gte": five_day_ago, "$lte": now_time}
                elif "endTime" in list(parameter.keys()):
                    parameter["endTime"] = now_time
                    query["createdTime"] = {"$lte": now_time}
                elif "startTime" in list(parameter.keys()):
                    parameter["startTime"] = five_day_ago
                    query["createdTime"] = {"$gte": five_day_ago}
    
                if "symbol" in list(parameter.keys()):
                    query["symbolId"] = order_request.get_symbolid(parameter["symbol"])
                if "forceClose" in list(parameter.keys()):
                    query["forceClose"] = parameter["forceClose"]
                if "state" in list(parameter.keys()):
                    if parameter["state"] == "UNFINISHED":
                        query["state"] = {"$in": [1, 2]}
                    elif parameter["state"] != "HISTORY":
                        query["state"] = order_request.get_enumerate_by_state(parameter["state"])
            path, method = self.request_data["list"]["path"], self.request_data["list"]["method"]
            if parameter is None:
                parameter = {}
            header = generate_auth_info(path=path, method=method, params=parameter)
            # 获取返回数据
            res = order_request.list(parm=parameter,header=header)
            logger.info(f'查询订单列表接口---&gt;{case_name}--&gt;参数为{parameter}---&gt;返回结果{res}')
            mongo_count = order_request.mongo.get_find_count(query)
            # result = res["result"]
&gt;           assert res["msgInfo"] == expected_result["msgInfo"]
E           KeyError: 'msgInfo'

test_cases/contract/client/order/test_list.py:66: KeyError</failure></testcase><testcase classname="test_cases.contract.client.order.test_list.TestOrderList" name="test_list_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_list_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_list.py:70">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_list.py:71: got empty parameter set ['test_data'], function test_list_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_list.py:70</skipped></testcase><testcase classname="test_cases.contract.client.order.test_list_history.TestListHistory" name="test_list_history_success[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_list_history_success at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_list_history.py:68">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_list_history.py:69: got empty parameter set ['test_data'], function test_list_history_success at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_list_history.py:68</skipped></testcase><testcase classname="test_cases.contract.client.order.test_order_list_by_ids.Test_order_list_by_ids" name="test_order_list_by_ids[main-单个id正常查询-10029012-success-0-]" time="2.834" /><testcase classname="test_cases.contract.client.order.test_trade_list.TestTradeList" name="test_trade_list_success[test_data0]" time="0.381"><failure message="KeyError: 'msgInfo'">self = &lt;thanos_test.test_cases.contract.client.order.test_trade_list.TestTradeList object at 0x110ac0250&gt;
test_data = {'trade_list_failed': {}, 'trade_list_success': {'all_parameter': {'expected_result': {'msgInfo': 'success'}, 'name': ...id': {'expected_result': {'msgInfo': 'success'}, 'name': 'main-只输入订单ID', 'parameter': {'orderId': 72566079020379712}}}}

    @pytest.mark.parametrize("test_data",[] if test_data.get("trade_list_success") == {} else [test_data])
    def test_trade_list_success(self,test_data):
        order_request = self.order_request
        cases_data = test_data["trade_list_success"]
        for value in cases_data.values():
            # 获取用例数据
            order_request.mongo.update_col("order")
            case_name, parameter = value["name"], value["parameter"]
            expected_result = value["expected_result"]
            # 根据参数判断是否有订单id,没有动态去mongo获取一个已经成交的订单id
            order_request.mongo.update_col("order")
            if not parameter["orderId"]:
                order_res = order_request.mongo.find_one({"accountId":order_request.account_id,"state":3})
                parameter["orderId"] = order_res["_id"]
            # 发送请求，获取结果返回数据
            res = order_request.trade_list(parm=parameter)
            logger.info(f'查询交易明细的正向测试用例---&gt;{case_name}--&gt;参数为{parameter}---&gt;返回结果{res}')
            # 去mongo拿成交信息
            order_request.mongo.update_col("trade")
            mongo_res = order_request.mongo.ascending_sort_find(query={"orderId":parameter["orderId"]},sort_field="id")
&gt;           assert res["msgInfo"] == expected_result["msgInfo"]
E           KeyError: 'msgInfo'

test_cases/contract/client/order/test_trade_list.py:39: KeyError</failure></testcase><testcase classname="test_cases.contract.client.order.test_trade_list.TestTradeList" name="test_trade_list_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_trade_list_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_trade_list.py:56">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_trade_list.py:57: got empty parameter set ['test_data'], function test_trade_list_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order/test_trade_list.py:56</skipped></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_cancel.Test_order_entrust_cancel" name="test_order_entrust_cancel[scene0-id0-type0-code0-except_msg0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['scene', 'id', 'type', 'code', 'except_msg'], function test_order_entrust_cancel at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order_entrust/test_order_entrust_cancel.py:16">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order_entrust/test_order_entrust_cancel.py:17: got empty parameter set ['scene', 'id', 'type', 'code', 'except_msg'], function test_order_entrust_cancel at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order_entrust/test_order_entrust_cancel.py:16</skipped></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_cancel_all.Test_order_entrust_cancel_all" name="test_order_entrust_cancel_all[scene0-symbol0-code0-except_msg0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['scene', 'symbol', 'code', 'except_msg'], function test_order_entrust_cancel_all at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order_entrust/test_order_entrust_cancel_all.py:18">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/order_entrust/test_order_entrust_cancel_all.py:19: got empty parameter set ['scene', 'symbol', 'code', 'except_msg'], function test_order_entrust_cancel_all at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/order_entrust/test_order_entrust_cancel_all.py:18</skipped></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-存在的symbol-------btc_usdt--0-]" time="3.285" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态NEW------NEW---0-]" time="21.498"><failure message="pymongo.errors.ConfigurationError: The DNS operation timed out after 21.148076057434082 seconds">self = &lt;pymongo.srv_resolver._SrvResolver object at 0x1111c4b20&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
&gt;           results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('_mongodb._tcp.cluster0.2ksbi.mongodb.net', 'SRV')
kwargs = {'lifetime': 20.0}

    def _resolve(*args, **kwargs):
        if hasattr(resolver, 'resolve'):
            # dnspython &gt;= 2
&gt;           return resolver.resolve(*args, **kwargs)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True,
                source_port=0, lifetime=None, search=None):
        """Query nameservers to find the answer to the question.
    
        This is a convenience function that uses the default resolver
        object to make the query.
    
        See ``dns.resolver.Resolver.resolve`` for more information on the
        parameters.
        """
    
&gt;       return get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,
                                              raise_on_no_answer, source_port,
                                              lifetime, search)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;
qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True, source_port=0,
                lifetime=None, search=None):  # pylint: disable=arguments-differ
        """Query nameservers to find the answer to the question.
    
        The *qname*, *rdtype*, and *rdclass* parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.
    
        *qname*, a ``dns.name.Name`` or ``str``, the query name.
    
        *rdtype*, an ``int`` or ``str``,  the query type.
    
        *rdclass*, an ``int`` or ``str``,  the query class.
    
        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
    
        *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
        address when making queries.
    
        *raise_on_no_answer*, a ``bool``.  If ``True``, raise
        ``dns.resolver.NoAnswer`` if there's no answer to the question.
    
        *source_port*, an ``int``, the port from which to send the message.
    
        *lifetime*, a ``float``, how many seconds a query should run
         before timing out.
    
        *search*, a ``bool`` or ``None``, determines whether the
        search list configured in the system's resolver configuration
        are used for relative names, and whether the resolver's domain
        may be added to relative names.  The default is ``None``,
        which causes the value of the resolver's
        ``use_search_by_default`` attribute to be used.
    
        Raises ``dns.exception.Timeout`` if no answers could be found
        in the specified lifetime.
    
        Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
    
        Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
        DNAME substitution.
    
        Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
        ``True`` and the query name exists but has no RRset of the
        desired type and class.
    
        Raises ``dns.resolver.NoNameservers`` if no non-broken
        nameservers are available to answer the question.
    
        Returns a ``dns.resolver.Answer`` instance.
    
        """
    
        resolution = _Resolution(self, qname, rdtype, rdclass, tcp,
                                 raise_on_no_answer, search)
        start = time.time()
        while True:
            (request, answer) = resolution.next_request()
            # Note we need to say "if answer is not None" and not just
            # "if answer" because answer implements __len__, and python
            # will call that.  We want to return if we have an answer
            # object, including in cases where its length is 0.
            if answer is not None:
                # cache hit!
                return answer
            done = False
            while not done:
                (nameserver, port, tcp, backoff) = resolution.next_nameserver()
                if backoff:
                    time.sleep(backoff)
&gt;               timeout = self._compute_timeout(start, lifetime)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;, start = 1647239680.820897
lifetime = 20.0

    def _compute_timeout(self, start, lifetime=None):
        lifetime = self.lifetime if lifetime is None else lifetime
        now = time.time()
        duration = now - start
        if duration &lt; 0:
            if duration &lt; -1:
                # Time going backwards is bad.  Just give up.
                raise Timeout(timeout=duration)
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        if duration &gt;= lifetime:
&gt;           raise Timeout(timeout=duration)
E           dns.exception.Timeout: The DNS operation timed out after 21.148076057434082 seconds

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:997: Timeout

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list object at 0x111084c10&gt;
scene = 'main-订单状态NEW', endTime = '', forceClose = '', page = '', size = ''
startTime = '', state = 'NEW', symbol = '', type = '', code = 0, except_msg = ''

    @pytest.mark.single
    @pytest.mark.parametrize("scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg",
                             api_order_entrust["order_entrust_list"])
    def test_order_entrust_list(self,scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{endTime}-{forceClose}-{page}-{size}\
                    -{startTime}-{state}-{symbol}-{type}-{code}-"{except_msg}"')
        result = order_entrust_list(scene,endTime,forceClose,page,size,startTime,state,symbol,type)
        logger.warning(f'场景-[{scene}]的返回信息是：{result.response}')
    
        # try:
        args = {
            "col": "order",
        }
        # 未出现 error的场景
        if result.response.get("error") is None :
                # 返回结果有数据
                if result.response.get("result").get("items") != [] :
                    # 随机挑选一个测试数据
                    choice_res = random.choice(result.response.get("result").get("items"))
                    logger.info("choice_res : is {}".format(choice_res))
                    # 根据 订单Id 查询订单表
&gt;                   res = MongoDb(args).find({"_id":int(choice_res.get("id"))})

test_cases/contract/client/order_entrust/test_order_entrust_list.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/mongodb_operate.py:25: in __init__
    self.client = pymongo.MongoClient(db_conf["url"])
../../Library/Python/3.8/lib/python/site-packages/pymongo/mongo_client.py:670: in __init__
    res = uri_parser.parse_uri(
../../Library/Python/3.8/lib/python/site-packages/pymongo/uri_parser.py:524: in parse_uri
    nodes = dns_resolver.get_hosts()
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:118: in get_hosts
    _, nodes = self._get_srv_response_and_hosts(True)
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:99: in _get_srv_response_and_hosts
    results = self._resolve_uri(encapsulate_errors)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymongo.srv_resolver._SrvResolver object at 0x1111c4b20&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
            results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)
        except Exception as exc:
            if not encapsulate_errors:
                # Raise the original error.
                raise
            # Else, raise all errors as ConfigurationError.
&gt;           raise ConfigurationError(str(exc))
E           pymongo.errors.ConfigurationError: The DNS operation timed out after 21.148076057434082 seconds

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:95: ConfigurationError</failure></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态PARTIALLY_FILLED------PARTIALLY_FILLED---0-]" time="0.160" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态FILLED------FILLED---0-]" time="21.748"><failure message="pymongo.errors.ConfigurationError: The DNS operation timed out after 21.143411874771118 seconds">self = &lt;pymongo.srv_resolver._SrvResolver object at 0x110f7a9d0&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
&gt;           results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('_mongodb._tcp.cluster0.2ksbi.mongodb.net', 'SRV')
kwargs = {'lifetime': 20.0}

    def _resolve(*args, **kwargs):
        if hasattr(resolver, 'resolve'):
            # dnspython &gt;= 2
&gt;           return resolver.resolve(*args, **kwargs)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True,
                source_port=0, lifetime=None, search=None):
        """Query nameservers to find the answer to the question.
    
        This is a convenience function that uses the default resolver
        object to make the query.
    
        See ``dns.resolver.Resolver.resolve`` for more information on the
        parameters.
        """
    
&gt;       return get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,
                                              raise_on_no_answer, source_port,
                                              lifetime, search)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;
qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True, source_port=0,
                lifetime=None, search=None):  # pylint: disable=arguments-differ
        """Query nameservers to find the answer to the question.
    
        The *qname*, *rdtype*, and *rdclass* parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.
    
        *qname*, a ``dns.name.Name`` or ``str``, the query name.
    
        *rdtype*, an ``int`` or ``str``,  the query type.
    
        *rdclass*, an ``int`` or ``str``,  the query class.
    
        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
    
        *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
        address when making queries.
    
        *raise_on_no_answer*, a ``bool``.  If ``True``, raise
        ``dns.resolver.NoAnswer`` if there's no answer to the question.
    
        *source_port*, an ``int``, the port from which to send the message.
    
        *lifetime*, a ``float``, how many seconds a query should run
         before timing out.
    
        *search*, a ``bool`` or ``None``, determines whether the
        search list configured in the system's resolver configuration
        are used for relative names, and whether the resolver's domain
        may be added to relative names.  The default is ``None``,
        which causes the value of the resolver's
        ``use_search_by_default`` attribute to be used.
    
        Raises ``dns.exception.Timeout`` if no answers could be found
        in the specified lifetime.
    
        Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
    
        Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
        DNAME substitution.
    
        Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
        ``True`` and the query name exists but has no RRset of the
        desired type and class.
    
        Raises ``dns.resolver.NoNameservers`` if no non-broken
        nameservers are available to answer the question.
    
        Returns a ``dns.resolver.Answer`` instance.
    
        """
    
        resolution = _Resolution(self, qname, rdtype, rdclass, tcp,
                                 raise_on_no_answer, search)
        start = time.time()
        while True:
            (request, answer) = resolution.next_request()
            # Note we need to say "if answer is not None" and not just
            # "if answer" because answer implements __len__, and python
            # will call that.  We want to return if we have an answer
            # object, including in cases where its length is 0.
            if answer is not None:
                # cache hit!
                return answer
            done = False
            while not done:
                (nameserver, port, tcp, backoff) = resolution.next_nameserver()
                if backoff:
                    time.sleep(backoff)
&gt;               timeout = self._compute_timeout(start, lifetime)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;, start = 1647239702.832818
lifetime = 20.0

    def _compute_timeout(self, start, lifetime=None):
        lifetime = self.lifetime if lifetime is None else lifetime
        now = time.time()
        duration = now - start
        if duration &lt; 0:
            if duration &lt; -1:
                # Time going backwards is bad.  Just give up.
                raise Timeout(timeout=duration)
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        if duration &gt;= lifetime:
&gt;           raise Timeout(timeout=duration)
E           dns.exception.Timeout: The DNS operation timed out after 21.143411874771118 seconds

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:997: Timeout

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list object at 0x11121f9d0&gt;
scene = 'main-订单状态FILLED', endTime = '', forceClose = '', page = '', size = ''
startTime = '', state = 'FILLED', symbol = '', type = '', code = 0
except_msg = ''

    @pytest.mark.single
    @pytest.mark.parametrize("scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg",
                             api_order_entrust["order_entrust_list"])
    def test_order_entrust_list(self,scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{endTime}-{forceClose}-{page}-{size}\
                    -{startTime}-{state}-{symbol}-{type}-{code}-"{except_msg}"')
        result = order_entrust_list(scene,endTime,forceClose,page,size,startTime,state,symbol,type)
        logger.warning(f'场景-[{scene}]的返回信息是：{result.response}')
    
        # try:
        args = {
            "col": "order",
        }
        # 未出现 error的场景
        if result.response.get("error") is None :
                # 返回结果有数据
                if result.response.get("result").get("items") != [] :
                    # 随机挑选一个测试数据
                    choice_res = random.choice(result.response.get("result").get("items"))
                    logger.info("choice_res : is {}".format(choice_res))
                    # 根据 订单Id 查询订单表
&gt;                   res = MongoDb(args).find({"_id":int(choice_res.get("id"))})

test_cases/contract/client/order_entrust/test_order_entrust_list.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/mongodb_operate.py:25: in __init__
    self.client = pymongo.MongoClient(db_conf["url"])
../../Library/Python/3.8/lib/python/site-packages/pymongo/mongo_client.py:670: in __init__
    res = uri_parser.parse_uri(
../../Library/Python/3.8/lib/python/site-packages/pymongo/uri_parser.py:524: in parse_uri
    nodes = dns_resolver.get_hosts()
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:118: in get_hosts
    _, nodes = self._get_srv_response_and_hosts(True)
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:99: in _get_srv_response_and_hosts
    results = self._resolve_uri(encapsulate_errors)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymongo.srv_resolver._SrvResolver object at 0x110f7a9d0&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
            results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)
        except Exception as exc:
            if not encapsulate_errors:
                # Raise the original error.
                raise
            # Else, raise all errors as ConfigurationError.
&gt;           raise ConfigurationError(str(exc))
E           pymongo.errors.ConfigurationError: The DNS operation timed out after 21.143411874771118 seconds

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:95: ConfigurationError</failure></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态CANCELED------CANCELED---0-]" time="16.757" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态REJECTED------REJECTED---0-]" time="0.444" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态EXPIRED------EXPIRED---0-]" time="9.271" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态UNFINISHED------UNFINISHED---0-]" time="8.414" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-订单状态HISTORY------HISTORY---0-]" time="21.398"><failure message="pymongo.errors.ConfigurationError: The DNS operation timed out after 21.146164894104004 seconds">self = &lt;pymongo.srv_resolver._SrvResolver object at 0x110f975e0&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
&gt;           results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('_mongodb._tcp.cluster0.2ksbi.mongodb.net', 'SRV')
kwargs = {'lifetime': 20.0}

    def _resolve(*args, **kwargs):
        if hasattr(resolver, 'resolve'):
            # dnspython &gt;= 2
&gt;           return resolver.resolve(*args, **kwargs)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True,
                source_port=0, lifetime=None, search=None):
        """Query nameservers to find the answer to the question.
    
        This is a convenience function that uses the default resolver
        object to make the query.
    
        See ``dns.resolver.Resolver.resolve`` for more information on the
        parameters.
        """
    
&gt;       return get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,
                                              raise_on_no_answer, source_port,
                                              lifetime, search)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;
qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True, source_port=0,
                lifetime=None, search=None):  # pylint: disable=arguments-differ
        """Query nameservers to find the answer to the question.
    
        The *qname*, *rdtype*, and *rdclass* parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.
    
        *qname*, a ``dns.name.Name`` or ``str``, the query name.
    
        *rdtype*, an ``int`` or ``str``,  the query type.
    
        *rdclass*, an ``int`` or ``str``,  the query class.
    
        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
    
        *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
        address when making queries.
    
        *raise_on_no_answer*, a ``bool``.  If ``True``, raise
        ``dns.resolver.NoAnswer`` if there's no answer to the question.
    
        *source_port*, an ``int``, the port from which to send the message.
    
        *lifetime*, a ``float``, how many seconds a query should run
         before timing out.
    
        *search*, a ``bool`` or ``None``, determines whether the
        search list configured in the system's resolver configuration
        are used for relative names, and whether the resolver's domain
        may be added to relative names.  The default is ``None``,
        which causes the value of the resolver's
        ``use_search_by_default`` attribute to be used.
    
        Raises ``dns.exception.Timeout`` if no answers could be found
        in the specified lifetime.
    
        Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
    
        Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
        DNAME substitution.
    
        Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
        ``True`` and the query name exists but has no RRset of the
        desired type and class.
    
        Raises ``dns.resolver.NoNameservers`` if no non-broken
        nameservers are available to answer the question.
    
        Returns a ``dns.resolver.Answer`` instance.
    
        """
    
        resolution = _Resolution(self, qname, rdtype, rdclass, tcp,
                                 raise_on_no_answer, search)
        start = time.time()
        while True:
            (request, answer) = resolution.next_request()
            # Note we need to say "if answer is not None" and not just
            # "if answer" because answer implements __len__, and python
            # will call that.  We want to return if we have an answer
            # object, including in cases where its length is 0.
            if answer is not None:
                # cache hit!
                return answer
            done = False
            while not done:
                (nameserver, port, tcp, backoff) = resolution.next_nameserver()
                if backoff:
                    time.sleep(backoff)
&gt;               timeout = self._compute_timeout(start, lifetime)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;, start = 1647239759.251772
lifetime = 20.0

    def _compute_timeout(self, start, lifetime=None):
        lifetime = self.lifetime if lifetime is None else lifetime
        now = time.time()
        duration = now - start
        if duration &lt; 0:
            if duration &lt; -1:
                # Time going backwards is bad.  Just give up.
                raise Timeout(timeout=duration)
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        if duration &gt;= lifetime:
&gt;           raise Timeout(timeout=duration)
E           dns.exception.Timeout: The DNS operation timed out after 21.146164894104004 seconds

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:997: Timeout

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list object at 0x110e46520&gt;
scene = 'main-订单状态HISTORY', endTime = '', forceClose = '', page = '', size = ''
startTime = '', state = 'HISTORY', symbol = '', type = '', code = 0
except_msg = ''

    @pytest.mark.single
    @pytest.mark.parametrize("scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg",
                             api_order_entrust["order_entrust_list"])
    def test_order_entrust_list(self,scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{endTime}-{forceClose}-{page}-{size}\
                    -{startTime}-{state}-{symbol}-{type}-{code}-"{except_msg}"')
        result = order_entrust_list(scene,endTime,forceClose,page,size,startTime,state,symbol,type)
        logger.warning(f'场景-[{scene}]的返回信息是：{result.response}')
    
        # try:
        args = {
            "col": "order",
        }
        # 未出现 error的场景
        if result.response.get("error") is None :
                # 返回结果有数据
                if result.response.get("result").get("items") != [] :
                    # 随机挑选一个测试数据
                    choice_res = random.choice(result.response.get("result").get("items"))
                    logger.info("choice_res : is {}".format(choice_res))
                    # 根据 订单Id 查询订单表
&gt;                   res = MongoDb(args).find({"_id":int(choice_res.get("id"))})

test_cases/contract/client/order_entrust/test_order_entrust_list.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/mongodb_operate.py:25: in __init__
    self.client = pymongo.MongoClient(db_conf["url"])
../../Library/Python/3.8/lib/python/site-packages/pymongo/mongo_client.py:670: in __init__
    res = uri_parser.parse_uri(
../../Library/Python/3.8/lib/python/site-packages/pymongo/uri_parser.py:524: in parse_uri
    nodes = dns_resolver.get_hosts()
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:118: in get_hosts
    _, nodes = self._get_srv_response_and_hosts(True)
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:99: in _get_srv_response_and_hosts
    results = self._resolve_uri(encapsulate_errors)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymongo.srv_resolver._SrvResolver object at 0x110f975e0&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
            results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)
        except Exception as exc:
            if not encapsulate_errors:
                # Raise the original error.
                raise
            # Else, raise all errors as ConfigurationError.
&gt;           raise ConfigurationError(str(exc))
E           pymongo.errors.ConfigurationError: The DNS operation timed out after 21.146164894104004 seconds

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:95: ConfigurationError</failure></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-是否强平true--true-------0-]" time="3.595"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x110e83460&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x1111d1700&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110e83940&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list object at 0x11122f700&gt;
scene = 'main-是否强平true', endTime = '', forceClose = 'true', page = '', size = ''
startTime = '', state = '', symbol = '', type = '', code = 0, except_msg = ''

    @pytest.mark.single
    @pytest.mark.parametrize("scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg",
                             api_order_entrust["order_entrust_list"])
    def test_order_entrust_list(self,scene,endTime,forceClose,page,size,startTime,state,symbol,type,code,except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{endTime}-{forceClose}-{page}-{size}\
                    -{startTime}-{state}-{symbol}-{type}-{code}-"{except_msg}"')
&gt;       result = order_entrust_list(scene,endTime,forceClose,page,size,startTime,state,symbol,type)

test_cases/contract/client/order_entrust/test_order_entrust_list.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/order_entrust/order_entrust_list.py:24: in order_entrust_list
    res = xtthanos_trade_http.order_entrust_list(headers=headers, params=params)
api/thanos_http.py:123: in order_entrust_list
    return requests(order_entrust_cancel_list.get('path'), **kwargs)
api/http_api.py:16: in get
    return self.request(url, "GET", **kwargs)
api/http_api.py:39: in request
    return self.session.get(url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:555: in get
    return self.request('GET', url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-endTime不存在-1--------0-]" time="0.377" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-startTime不存在-----1----0-]" time="18.133" /><testcase classname="test_cases.contract.client.order_entrust.test_order_entrust_list.Test_order_entrust_list" name="test_order_entrust_list[main-endTime大于startTime---------0-]" time="7.226" /><testcase classname="test_cases.contract.client.plan_order.test_cancel_all.TestCancelAll" name="test_cancel_all_plan_success[test_data0]" time="3.451"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1111bf9d0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x1109dff40&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1111bff10&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.plan_order.test_cancel_all.TestCancelAll object at 0x11114fac0&gt;
test_data = {'cancel_all_plan_failed': {}, 'cancel_all_plan_success': {'cancel_all': {'create_parameter_1': {'entrustType': 'TAKE_...rigQty': '5', 'positionSide': 'LONG', ...}, 'expected_result': {'msgInfo': 'success'}, 'name': 'main-传交易对撤销该交易对计划委托'}}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("cancel_all_plan_success") == {} else [test_data])
    def test_cancel_all_plan_success(self, test_data):
        cases_data = test_data["cancel_all_plan_success"]
        self.plan_request.mongo.update_col("entrust")
        for case_data in cases_data.values():
            # （1）读取文件数据
            case_name, expected_result = case_data["name"], case_data["expected_result"]
            create_parameter_1, create_parameter_2 = case_data["create_parameter_1"], case_data["create_parameter_2"]
            # （2）拼接创建计划委托的参数
            create_parameter_1["price"] = float(self.dao_mark_price) + 0.1
            create_parameter_1["stopPrice"] = float(self.dao_mark_price) + 0.1
            if create_parameter_2["symbol"] == "dao_usdt":
                create_parameter_2["price"] = float(self.ada_mark_price) + 0.1
                create_parameter_2["stopPrice"] = float(self.ada_mark_price) + 0.1
            else:
                create_parameter_2["price"] = float(self.dao_mark_price) + 0.1
                create_parameter_2["stopPrice"] = float(self.dao_mark_price) + 0.1
            # (3) 两个不同的交易对下计划委托单
            create_entrust_1 = self.plan_request.create_plan(parm=create_parameter_1)
&gt;           create_entrust_2 = self.plan_request.create_plan(parm=create_parameter_2)

test_cases/contract/client/plan_order/test_cancel_all.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/plan_order/plan_request.py:72: in create_plan
    res = xtthanos_trade_http.create_plan(headers=header, params=parm)
api/thanos_http.py:214: in create_plan
    return requests(create_plan.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.plan_order.test_cancel_all.TestCancelAll" name="test_cancel_all_plan_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_cancel_all_plan_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_all.py:63">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_all.py:64: got empty parameter set ['test_data'], function test_cancel_all_plan_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_all.py:63</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_cancel_all_profit.TestCancelAllProfit" name="test_cancel_all_profit_success[test_data0]" time="1.092" /><testcase classname="test_cases.contract.client.plan_order.test_cancel_all_profit.TestCancelAllProfit" name="test_cancel_all_profit_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_cancel_all_profit_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_all_profit.py:43">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_all_profit.py:44: got empty parameter set ['test_data'], function test_cancel_all_profit_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_all_profit.py:43</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_cancel_entrust.TestCancelPlan" name="test_cancel_plan_success[test_data0]" time="0.653" /><testcase classname="test_cases.contract.client.plan_order.test_cancel_entrust.TestCancelPlan" name="test_cancel_plan_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_cancel_plan_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_entrust.py:43">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_entrust.py:44: got empty parameter set ['test_data'], function test_cancel_plan_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_entrust.py:43</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_cancel_profit.TestCancelProfit" name="test_cancel_profit_success[test_data0]" time="1.250"><error message="failed on setup with &quot;requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))&quot;">self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1110b3700&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x110a96180&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1110b3820&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;class 'thanos_test.test_cases.contract.client.plan_order.test_cancel_profit.TestCancelProfit'&gt;

    def setup_class(self):
&gt;       set_up_position()

test_cases/contract/client/plan_order/test_cancel_profit.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/set_up_balance_and_position.py:41: in set_up_position
    position_list = get_position(symbol).response["result"]
operation/contract/client/position/get_position.py:19: in get_position
    res = xtthanos_user_http.get_position(headers=headers, params=params)
api/thanos_http.py:43: in get_position
    return requests(position_list.get('path'), **kwargs)
api/http_api.py:16: in get
    return self.request(url, "GET", **kwargs)
api/http_api.py:39: in request
    return self.session.get(url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:555: in get
    return self.request('GET', url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</error></testcase><testcase classname="test_cases.contract.client.plan_order.test_cancel_profit.TestCancelProfit" name="test_cancel_profit_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_cancel_profit_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_profit.py:53">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_profit.py:54: got empty parameter set ['test_data'], function test_cancel_profit_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_cancel_profit.py:53</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_create_plan.TestCreatePlan" name="test_create_plan_success[test_data0]" time="6.027"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x110f991c0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x111261b00&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f99e80&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.plan_order.test_create_plan.TestCreatePlan object at 0x1112e0e50&gt;
test_data = {'create_plan_failed': {}, 'create_plan_success': {'buy_long_ioc_mark_price': {'expected_result': {'msgInfo': 'success...于当前价格、最新价格', 'parameter': {'entrustType': 'STOP', 'orderSide': 'SELL', 'origQty': '5', 'positionSide': 'SHORT', ...}}}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("create_plan_success") == {} else [test_data])
    def test_create_plan_success(self, test_data):
        """1、动态拼接价格和触发价格
           2、根据拼接的参数发起请求
           3、断言，比对数据"""
        cases_data = test_data["create_plan_success"]
        self.plan_request.mongo.update_col("entrust")
        price_dict = {
            "good_than_mark_price": round(float(self.mark_price) + 0.1, 3),
            "less_than_mark_price": round(float(self.mark_price) - 0.1, 3),
            "good_than_latest_price": round(float(self.mark_price) + 0.1, 3),
            "less_than_latest_price": round(float(self.mark_price) - 0.1, 3)
        }
        for case_data in cases_data.values():
            parameter, case_name, expected_result = case_data["parameter"], case_data["name"], case_data[
                "expected_result"]
            # 根据参数动态传入触发价格和止盈止盈价格
            parameter["price"] = price_dict.get(parameter.get("price"))
            parameter["stopPrice"] = price_dict.get(parameter.get("stopPrice"))
            # 发起请求获取断言
&gt;           res = self.plan_request.create_plan(parm=parameter)

test_cases/contract/client/plan_order/test_create_plan.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/plan_order/plan_request.py:72: in create_plan
    res = xtthanos_trade_http.create_plan(headers=header, params=parm)
api/thanos_http.py:214: in create_plan
    return requests(create_plan.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.plan_order.test_create_plan.TestCreatePlan" name="test_create_plan_failed[test_data0]" time="1.282"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_create_plan_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_plan.py:66">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_plan.py:67: got empty parameter set ['test_data'], function test_create_plan_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_plan.py:66</skipped><error message="failed on teardown with &quot;requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))&quot;">self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1112680a0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x1113a6940&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112680d0&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;class 'thanos_test.test_cases.contract.client.plan_order.test_create_plan.TestCreatePlan'&gt;

    def teardown_class(self):
        """后置处理，撤销所有的计划委托"""
&gt;       self.plan_request.cancel_all_plan()

test_cases/contract/client/plan_order/test_create_plan.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/plan_order/plan_request.py:28: in cancel_all_plan
    res = xtthanos_trade_http.cancel_all_plan(headers=header)
api/thanos_http.py:220: in cancel_all_plan
    return requests(cancel_all_plan.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</error></testcase><testcase classname="test_cases.contract.client.plan_order.test_create_profit.TestCreateProfit" name="test_plan_create_profit_success[test_data0]" time="2.707"><error message="failed on setup with &quot;requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))&quot;">self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1113dc370&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x10eb73a80&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1113dc5e0&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;class 'thanos_test.test_cases.contract.client.plan_order.test_create_profit.TestCreateProfit'&gt;

    def setup_class(self):
        """前置处理，撤销所有的止盈止损，创建持仓"""
        self.plan_request.cancel_all_profit_stop()
&gt;       set_up_position()

test_cases/contract/client/plan_order/test_create_profit.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/set_up_balance_and_position.py:66: in set_up_position
    order_request.create(parm=user1_parm, test_user="test_user")
operation/contract/client/order/order_request.py:55: in create
    res = xtthanos_trade_http.create(headers=header, params=parm)
api/thanos_http.py:190: in create
    return requests(create.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</error></testcase><testcase classname="test_cases.contract.client.plan_order.test_create_profit.TestCreateProfit" name="test_had_profit_create_profit[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_had_profit_create_profit at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:60">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:61: got empty parameter set ['test_data'], function test_had_profit_create_profit at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:60</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_create_profit.TestCreateProfit" name="test_create_profit_without_position[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_create_profit_without_position at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:87">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:88: got empty parameter set ['test_data'], function test_create_profit_without_position at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:87</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_create_profit.TestCreateProfit" name="test_invalid_parameter_create_profit[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_invalid_parameter_create_profit at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:109">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:110: got empty parameter set ['test_data'], function test_invalid_parameter_create_profit at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_create_profit.py:109</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_plan_detail.TestPlanDetail" name="test_plan_detail_success[test_data0]" time="0.658" /><testcase classname="test_cases.contract.client.plan_order.test_plan_detail.TestPlanDetail" name="test_plan_detail_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_plan_detail_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_plan_detail.py:44">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_plan_detail.py:45: got empty parameter set ['test_data'], function test_plan_detail_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_plan_detail.py:44</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_profit_detail.TestProfitDetail" name="test_profit_detail_success[test_data0]" time="0.326"><failure message="assert None">self = &lt;thanos_test.test_cases.contract.client.plan_order.test_profit_detail.TestProfitDetail object at 0x111351b20&gt;
test_data = {'profit_detail_failed': {}, 'profit_detail_success': {'correct_id': {'expected_result': {'msgInfo': 'success'}, 'name': 'main-id正确查询'}}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("plan_detail_failed") == {} else [test_data])
    def test_profit_detail_success(self, test_data):
        """id查询止盈止损的正向测试类"""
        self.plan_request.mongo.update_col("profit")
        cases_data = test_data["profit_detail_success"]
        for case_data in cases_data.values():
            name, expected_result = case_data["name"], case_data["expected_result"]
            # (1)从数据库中查找任一止盈止损id
            mongo_res = self.plan_request.mongo.find_one({"accountId": self.plan_request.account_id})
            # (2) 获取id,发起请求
            profit_id = mongo_res.get("_id")
            if profit_id:
                logger.info("从数据库中查找任一止盈止损id 为{}".format(profit_id))
                res = self.plan_request.profit_detail(profit_id=profit_id)
                logger.info(f"查询止盈止损正向用例 ==&gt;{name}===&gt;&gt;profit_id为{profit_id}=====&gt;&gt;返回结果 ==&gt;&gt; {res}")
                assert res["msgInfo"] == expected_result["msgInfo"]
                result = res.get("result")
                assert self.plan_request.get_symbolid(result["symbol"]) == mongo_res["symbolId"]
                assert self.plan_request.get_num_by_position_side(result["positionSide"]) == mongo_res["positionSide"]
                assert result["origQty"] == mongo_res["origQty"]
                assert Decimal(result["triggerProfitPrice"]) if result["triggerProfitPrice"] else None == mongo_res["triggerProfitPrice"]
&gt;               assert None if result.get("triggerStopPrice") is None else Decimal(result.get("triggerStopPrice")) ==\
                                                                   Decimal(mongo_res.get("triggerStopPrice"))
E               assert None

test_cases/contract/client/plan_order/test_profit_detail.py:39: AssertionError</failure></testcase><testcase classname="test_cases.contract.client.plan_order.test_profit_detail.TestProfitDetail" name="test_profit_detail_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_profit_detail_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_profit_detail.py:42">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_profit_detail.py:43: got empty parameter set ['test_data'], function test_profit_detail_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_profit_detail.py:42</skipped></testcase><testcase classname="test_cases.contract.client.plan_order.test_update_profit.TestUpdateProfit" name="test_update_profit_success[test_data0]" time="4.232"><error message="failed on setup with &quot;TypeError: float() argument must be a string or a number, not 'NoneType'&quot;">self = &lt;class 'thanos_test.test_cases.contract.client.plan_order.test_update_profit.TestUpdateProfit'&gt;

    def setup_class(self):
        """前置处理，初始化止盈止损，得到止盈止盈id、开仓价格"""
&gt;       self.long_profit_id = int(self.plan_request.create_default_profit())

test_cases/contract/client/plan_order/test_update_profit.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;operation.contract.client.plan_order.plan_request.PlanRequest object at 0x110bfca60&gt;
symbol = 'dao_usdt', header = None, position = 'LONG', origQty = 3
test_user = 'test_user'

    def create_default_profit(self, symbol="dao_usdt", header=None, position="LONG", origQty=3,test_user="test_user"):
        # 查询是否有止盈止盈，如果有，就直接返回止盈止损id
        profit_list_res = self.profit_list(parm={"symbol":symbol,"state":"NOT_TRIGGERED"})
        profit_list = jsonpath(profit_list_res,"$..items")
        if profit_list:
            id_list = [profit.get("profitId") for profit in profit_list[0] if profit.get("positionSide") == position]
            if id_list:
                return id_list[0]
        # (1)根据参数创建持仓
        set_up_position(symbol=symbol)
        # (2)获取持仓价格
        long_entry_price = float(Positon().get_entry_price(position="LONG"))
&gt;       short_entry_price = float(Positon().get_entry_price(position="SHORT"))
E       TypeError: float() argument must be a string or a number, not 'NoneType'

operation/contract/client/plan_order/plan_request.py:166: TypeError</error></testcase><testcase classname="test_cases.contract.client.plan_order.test_update_profit.TestUpdateProfit" name="test_update_profit_failed[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_update_profit_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_update_profit.py:72">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_update_profit.py:73: got empty parameter set ['test_data'], function test_update_profit_failed at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/plan_order/test_update_profit.py:72</skipped></testcase><testcase classname="test_cases.contract.client.position.test_adjust_auto_margin.Test_adjust_auto_margin" name="test_adjust_auto_margin[main-自动追加保证金正常，仓位方向LONG-True-LONG-dao_usdt-success-0-]" time="49.877"><failure message="pymongo.errors.ConfigurationError: The DNS operation timed out after 21.151846885681152 seconds">self = &lt;pymongo.srv_resolver._SrvResolver object at 0x1112cf6a0&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
&gt;           results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('_mongodb._tcp.cluster0.2ksbi.mongodb.net', 'SRV')
kwargs = {'lifetime': 20.0}

    def _resolve(*args, **kwargs):
        if hasattr(resolver, 'resolve'):
            # dnspython &gt;= 2
&gt;           return resolver.resolve(*args, **kwargs)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True,
                source_port=0, lifetime=None, search=None):
        """Query nameservers to find the answer to the question.
    
        This is a convenience function that uses the default resolver
        object to make the query.
    
        See ``dns.resolver.Resolver.resolve`` for more information on the
        parameters.
        """
    
&gt;       return get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,
                                              raise_on_no_answer, source_port,
                                              lifetime, search)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;
qname = '_mongodb._tcp.cluster0.2ksbi.mongodb.net', rdtype = 'SRV'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True, source_port=0,
                lifetime=None, search=None):  # pylint: disable=arguments-differ
        """Query nameservers to find the answer to the question.
    
        The *qname*, *rdtype*, and *rdclass* parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.
    
        *qname*, a ``dns.name.Name`` or ``str``, the query name.
    
        *rdtype*, an ``int`` or ``str``,  the query type.
    
        *rdclass*, an ``int`` or ``str``,  the query class.
    
        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
    
        *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
        address when making queries.
    
        *raise_on_no_answer*, a ``bool``.  If ``True``, raise
        ``dns.resolver.NoAnswer`` if there's no answer to the question.
    
        *source_port*, an ``int``, the port from which to send the message.
    
        *lifetime*, a ``float``, how many seconds a query should run
         before timing out.
    
        *search*, a ``bool`` or ``None``, determines whether the
        search list configured in the system's resolver configuration
        are used for relative names, and whether the resolver's domain
        may be added to relative names.  The default is ``None``,
        which causes the value of the resolver's
        ``use_search_by_default`` attribute to be used.
    
        Raises ``dns.exception.Timeout`` if no answers could be found
        in the specified lifetime.
    
        Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
    
        Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
        DNAME substitution.
    
        Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
        ``True`` and the query name exists but has no RRset of the
        desired type and class.
    
        Raises ``dns.resolver.NoNameservers`` if no non-broken
        nameservers are available to answer the question.
    
        Returns a ``dns.resolver.Answer`` instance.
    
        """
    
        resolution = _Resolution(self, qname, rdtype, rdclass, tcp,
                                 raise_on_no_answer, search)
        start = time.time()
        while True:
            (request, answer) = resolution.next_request()
            # Note we need to say "if answer is not None" and not just
            # "if answer" because answer implements __len__, and python
            # will call that.  We want to return if we have an answer
            # object, including in cases where its length is 0.
            if answer is not None:
                # cache hit!
                return answer
            done = False
            while not done:
                (nameserver, port, tcp, backoff) = resolution.next_nameserver()
                if backoff:
                    time.sleep(backoff)
&gt;               timeout = self._compute_timeout(start, lifetime)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;, start = 1647239861.021709
lifetime = 20.0

    def _compute_timeout(self, start, lifetime=None):
        lifetime = self.lifetime if lifetime is None else lifetime
        now = time.time()
        duration = now - start
        if duration &lt; 0:
            if duration &lt; -1:
                # Time going backwards is bad.  Just give up.
                raise Timeout(timeout=duration)
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        if duration &gt;= lifetime:
&gt;           raise Timeout(timeout=duration)
E           dns.exception.Timeout: The DNS operation timed out after 21.151846885681152 seconds

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:997: Timeout

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_auto_margin.Test_adjust_auto_margin object at 0x1110f0e80&gt;
scene = 'main-自动追加保证金正常，仓位方向LONG', autoMargin = True, positionSide = 'SHORT'
symbol = 'btc_usdt', except_result = 'success', except_returnCode = 0
except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,autoMargin,positionSide,symbol,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_auto_margin"])
    def test_adjust_auto_margin(self,scene,autoMargin,positionSide,symbol,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{autoMargin}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
    
        # 调用获取用户信息的接口，得到accountId
        account_id = get_account_info().response.get("result").get("accountId")
        # 获取当前symbol 的symbolId
        logger.info("当前用户 accountId 是{}".format(account_id))
        args = {
            "col": "position",
        }
        if scene.endswith("自动追加保证金正常，仓位方向LONG") or scene.endswith('自动追加保证金正常，仓位方向SHORT') or \
                scene.endswith("关闭自动追加保证金正常，仓位方向LONG") or scene.endswith('关闭自动追加保证金正常，仓位方向SHORT'):
            #   根据 accountId 在mongo找到一条position(持仓)信息
            res = MongoDb(args).find({"accountId": account_id})
            if scene.endswith('自动追加保证金正常，仓位方向LONG'):
                # 初始化交易对
                set_up_position(symbol="dao_usdt")
            for symbol_res in res:
                # entryPrice= 0 是垃圾数据
                if str(symbol_res.get('entryPrice')) != '0':
                    if symbol_res is not None:
                        logger.info("当前 {} 了自动追加保证金".format("开启" if symbol_res.get("autoMargin") else "关闭"))
                        if symbol_res.get('positionSide') == 2:
                            positionSide = 'SHORT'
                        if symbol_res.get('positionSide') == 1:
                            positionSide = 'LONG'
                        if symbol_res.get('positionSide') == 0:
                            positionSide = 'BOTH'
                        # 数据库获取当前持仓的交易对
                        symbol = s.query.filter(s.id == int(symbol_res.get("symbolId"))).first().symbol
                        logger.info("当前用户持仓信息中的交易对是:{} 持仓方向:{} autoMargin:{} ".format(symbol,positionSide,autoMargin))
                        # positionSide，symbol ,autoMargin 对作为接口传参
                        result = adjust_auto_margin(autoMargin, positionSide, symbol)
                        logger.warning(f'场景-[{scene}]的返回信息是：{result.response}')
                        time.sleep(2)
&gt;                       chenge_autoMargin = MongoDb(args).find_one({"accountId": account_id,"_id":symbol_res.get("_id")})

test_cases/contract/client/position/test_adjust_auto_margin.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/mongodb_operate.py:25: in __init__
    self.client = pymongo.MongoClient(db_conf["url"])
../../Library/Python/3.8/lib/python/site-packages/pymongo/mongo_client.py:670: in __init__
    res = uri_parser.parse_uri(
../../Library/Python/3.8/lib/python/site-packages/pymongo/uri_parser.py:524: in parse_uri
    nodes = dns_resolver.get_hosts()
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:118: in get_hosts
    _, nodes = self._get_srv_response_and_hosts(True)
../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:99: in _get_srv_response_and_hosts
    results = self._resolve_uri(encapsulate_errors)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymongo.srv_resolver._SrvResolver object at 0x1112cf6a0&gt;
encapsulate_errors = True

    def _resolve_uri(self, encapsulate_errors):
        try:
            results = _resolve('_mongodb._tcp.' + self.__fqdn, 'SRV',
                               lifetime=self.__connect_timeout)
        except Exception as exc:
            if not encapsulate_errors:
                # Raise the original error.
                raise
            # Else, raise all errors as ConfigurationError.
&gt;           raise ConfigurationError(str(exc))
E           pymongo.errors.ConfigurationError: The DNS operation timed out after 21.151846885681152 seconds

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:95: ConfigurationError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_auto_margin.Test_adjust_auto_margin" name="test_adjust_auto_margin[main-自动追加保证金正常，仓位方向SHORT-True-SHORT-dao_usdt-success-0-]" time="30.976"><failure message="pymongo.errors.ConfigurationError: The DNS operation timed out after 21.1510648727417 seconds">self = &lt;pymongo.srv_resolver._SrvResolver object at 0x1110475b0&gt;

    def get_options(self):
        try:
&gt;           results = _resolve(self.__fqdn, 'TXT',
                               lifetime=self.__connect_timeout)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('cluster0.2ksbi.mongodb.net', 'TXT'), kwargs = {'lifetime': 20.0}

    def _resolve(*args, **kwargs):
        if hasattr(resolver, 'resolve'):
            # dnspython &gt;= 2
&gt;           return resolver.resolve(*args, **kwargs)

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

qname = 'cluster0.2ksbi.mongodb.net', rdtype = 'TXT'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True,
                source_port=0, lifetime=None, search=None):
        """Query nameservers to find the answer to the question.
    
        This is a convenience function that uses the default resolver
        object to make the query.
    
        See ``dns.resolver.Resolver.resolve`` for more information on the
        parameters.
        """
    
&gt;       return get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,
                                              raise_on_no_answer, source_port,
                                              lifetime, search)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;
qname = 'cluster0.2ksbi.mongodb.net', rdtype = 'TXT'
rdclass = &lt;RdataClass.IN: 1&gt;, tcp = False, source = None
raise_on_no_answer = True, source_port = 0, lifetime = 20.0, search = None

    def resolve(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
                tcp=False, source=None, raise_on_no_answer=True, source_port=0,
                lifetime=None, search=None):  # pylint: disable=arguments-differ
        """Query nameservers to find the answer to the question.
    
        The *qname*, *rdtype*, and *rdclass* parameters may be objects
        of the appropriate type, or strings that can be converted into objects
        of the appropriate type.
    
        *qname*, a ``dns.name.Name`` or ``str``, the query name.
    
        *rdtype*, an ``int`` or ``str``,  the query type.
    
        *rdclass*, an ``int`` or ``str``,  the query class.
    
        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
    
        *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
        address when making queries.
    
        *raise_on_no_answer*, a ``bool``.  If ``True``, raise
        ``dns.resolver.NoAnswer`` if there's no answer to the question.
    
        *source_port*, an ``int``, the port from which to send the message.
    
        *lifetime*, a ``float``, how many seconds a query should run
         before timing out.
    
        *search*, a ``bool`` or ``None``, determines whether the
        search list configured in the system's resolver configuration
        are used for relative names, and whether the resolver's domain
        may be added to relative names.  The default is ``None``,
        which causes the value of the resolver's
        ``use_search_by_default`` attribute to be used.
    
        Raises ``dns.exception.Timeout`` if no answers could be found
        in the specified lifetime.
    
        Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
    
        Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
        DNAME substitution.
    
        Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
        ``True`` and the query name exists but has no RRset of the
        desired type and class.
    
        Raises ``dns.resolver.NoNameservers`` if no non-broken
        nameservers are available to answer the question.
    
        Returns a ``dns.resolver.Answer`` instance.
    
        """
    
        resolution = _Resolution(self, qname, rdtype, rdclass, tcp,
                                 raise_on_no_answer, search)
        start = time.time()
        while True:
            (request, answer) = resolution.next_request()
            # Note we need to say "if answer is not None" and not just
            # "if answer" because answer implements __len__, and python
            # will call that.  We want to return if we have an answer
            # object, including in cases where its length is 0.
            if answer is not None:
                # cache hit!
                return answer
            done = False
            while not done:
                (nameserver, port, tcp, backoff) = resolution.next_nameserver()
                if backoff:
                    time.sleep(backoff)
&gt;               timeout = self._compute_timeout(start, lifetime)

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;dns.resolver.Resolver object at 0x110892940&gt;, start = 1647239892.58923
lifetime = 20.0

    def _compute_timeout(self, start, lifetime=None):
        lifetime = self.lifetime if lifetime is None else lifetime
        now = time.time()
        duration = now - start
        if duration &lt; 0:
            if duration &lt; -1:
                # Time going backwards is bad.  Just give up.
                raise Timeout(timeout=duration)
            else:
                # Time went backwards, but only a little.  This can
                # happen, e.g. under vmware with older linux kernels.
                # Pretend it didn't happen.
                now = start
        if duration &gt;= lifetime:
&gt;           raise Timeout(timeout=duration)
E           dns.exception.Timeout: The DNS operation timed out after 21.1510648727417 seconds

../../Library/Python/3.8/lib/python/site-packages/dns/resolver.py:997: Timeout

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_auto_margin.Test_adjust_auto_margin object at 0x1110f09d0&gt;
scene = 'main-自动追加保证金正常，仓位方向SHORT', autoMargin = True, positionSide = 'SHORT'
symbol = 'dao_usdt', except_result = 'success', except_returnCode = 0
except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,autoMargin,positionSide,symbol,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_auto_margin"])
    def test_adjust_auto_margin(self,scene,autoMargin,positionSide,symbol,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{autoMargin}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
    
        # 调用获取用户信息的接口，得到accountId
        account_id = get_account_info().response.get("result").get("accountId")
        # 获取当前symbol 的symbolId
        logger.info("当前用户 accountId 是{}".format(account_id))
        args = {
            "col": "position",
        }
        if scene.endswith("自动追加保证金正常，仓位方向LONG") or scene.endswith('自动追加保证金正常，仓位方向SHORT') or \
                scene.endswith("关闭自动追加保证金正常，仓位方向LONG") or scene.endswith('关闭自动追加保证金正常，仓位方向SHORT'):
            #   根据 accountId 在mongo找到一条position(持仓)信息
&gt;           res = MongoDb(args).find({"accountId": account_id})

test_cases/contract/client/position/test_adjust_auto_margin.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/mongodb_operate.py:25: in __init__
    self.client = pymongo.MongoClient(db_conf["url"])
../../Library/Python/3.8/lib/python/site-packages/pymongo/mongo_client.py:670: in __init__
    res = uri_parser.parse_uri(
../../Library/Python/3.8/lib/python/site-packages/pymongo/uri_parser.py:525: in parse_uri
    dns_options = dns_resolver.get_options()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymongo.srv_resolver._SrvResolver object at 0x1110475b0&gt;

    def get_options(self):
        try:
            results = _resolve(self.__fqdn, 'TXT',
                               lifetime=self.__connect_timeout)
        except (resolver.NoAnswer, resolver.NXDOMAIN):
            # No TXT records
            return None
        except Exception as exc:
&gt;           raise ConfigurationError(str(exc))
E           pymongo.errors.ConfigurationError: The DNS operation timed out after 21.1510648727417 seconds

../../Library/Python/3.8/lib/python/site-packages/pymongo/srv_resolver.py:79: ConfigurationError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_auto_margin.Test_adjust_auto_margin" name="test_adjust_auto_margin[main-关闭自动追加保证金正常，仓位方向LONG-False-LONG-dao_usdt-success-0-]" time="27.583" /><testcase classname="test_cases.contract.client.position.test_adjust_auto_margin.Test_adjust_auto_margin" name="test_adjust_auto_margin[main-关闭自动追加保证金正常，仓位方向SHORT-False-SHORT-dao_usdt-success-0-]" time="8.488" /><testcase classname="test_cases.contract.client.position.test_adjust_leverage.Test_adjust_leverage" name="test_adjust_leverage[main-调整杠杆倍数,仓位方向为LONG-3-LONG-dao_usdt-success-0-]" time="2.992"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1113075e0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x111411dc0&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x111307c70&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_leverage.Test_adjust_leverage object at 0x1112db5b0&gt;
scene = 'main-调整杠杆倍数,仓位方向为LONG', leverage = 3, positionSide = 'LONG'
symbol = 'dao_usdt', except_result = 'success', except_returnCode = 0
except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,leverage,positionSide,symbol,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_leverage"])
    def test_adjust_leverage(self,scene,leverage,positionSide,symbol,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{leverage}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
        # 调用获取用户信息的接口，得到accountId
        account_info = get_account_info.get_account_info()
        curl_accountId = account_info.response.get("result").get("accountId")
    
        if scene.endswith('调整杠杆倍数,仓位方向为LONG'):
&gt;           set_down_position(symbol)

test_cases/contract/client/position/test_adjust_leverage.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/set_up_balance_and_position.py:83: in set_down_position
    order_entrust_cancel_all(symbol)
operation/contract/client/order_entrust/order_entrust_cancel_all.py:17: in order_entrust_cancel_all
    res = xtthanos_trade_http.order_entrust_cancel_all(headers=headers, params=params)
api/thanos_http.py:135: in order_entrust_cancel_all
    return requests(order_entrust_cancel_all.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_leverage.Test_adjust_leverage" name="test_adjust_leverage[main-调整杠杆倍数,仓位方向为SHORT-3-SHORT-dao_usdt-success-0-]" time="4.686" /><testcase classname="test_cases.contract.client.position.test_adjust_leverage.Test_adjust_leverage" name="test_adjust_leverage[main-存在活跃订单不能更改杠杆倍数-21-LONG-dao_usdt-failure-1-order exists]" time="1.390"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1113497f0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x111487640&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1115dd340&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_leverage.Test_adjust_leverage object at 0x1111673a0&gt;
scene = 'main-存在活跃订单不能更改杠杆倍数', leverage = 21, positionSide = 'LONG'
symbol = 'dao_usdt', except_result = 'failure', except_returnCode = 1
except_msg = 'order exists'

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,leverage,positionSide,symbol,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_leverage"])
    def test_adjust_leverage(self,scene,leverage,positionSide,symbol,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{leverage}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
        # 调用获取用户信息的接口，得到accountId
        account_info = get_account_info.get_account_info()
        curl_accountId = account_info.response.get("result").get("accountId")
    
        if scene.endswith('调整杠杆倍数,仓位方向为LONG'):
            set_down_position(symbol)
        if scene.endswith( '杠杆倍数等于设定值上限') or scene.endswith('杠杆倍数大于设定值上限'):
            # 获取用户当前可以开最大杠杆倍数
            position_leverage = get_position_max_adjust_leverage(symbol)
            logger.info("用户当前可以开最大杠杆倍数 为{}".format(position_leverage))
            position_max_adjust_leverage = position_leverage.get(positionSide).get('position_max_adjust_leverage')
            if scene.endswith( '杠杆倍数大于设定值上限'):
                set_down_position(symbol)
                # 将上限值加1
                position_max_adjust_leverage = int(position_max_adjust_leverage)+ 1
            result = adjust_leverage(position_max_adjust_leverage, positionSide, symbol)
            assert result.status_code == 200
            assert except_result == result.response["msgInfo"]
            assert except_returnCode == result.response["returnCode"]
            if except_returnCode == 0:
                assert except_msg in str(result.response["result"])
            else:
                assert except_msg in result.response["error"]["msg"]
            return
    
&gt;       result = adjust_leverage(leverage, positionSide, symbol)

test_cases/contract/client/position/test_adjust_leverage.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/position/adjust_leverage.py:21: in adjust_leverage
    res = xtthanos_user_http.adjust_leverage(headers=headers, params=params)
api/thanos_http.py:21: in adjust_leverage
    return requests(adjust_leverage.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin" name="test_adjust_margin[main-增加逐仓保证金，持仓方向LONG-20-LONG-dao_usdt-ADD-success-0-0]" time="2.217"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x110f7aa60&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x10eba4c80&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x110f7af10&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin object at 0x10fe60400&gt;
scene = 'main-增加逐仓保证金，持仓方向LONG', margin = 20, positionSide = 'LONG'
symbol = 'dao_usdt', type = 'ADD', except_result = 'success'
except_returnCode = 0, except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,margin,positionSide,symbol,type,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_margin"])
    def test_adjust_margin(self,scene,margin,positionSide,symbol,type,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{margin}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
        # 调用获取用户信息的接口，得到accountId
        account_id = get_account_info().response.get("result").get("accountId")
    
        # 获取当前symbol 的symbolId
        logger.info("当前用户 accountId 是{}".format(account_id))
        args = {
            "col": "position",
        }
        if scene.endswith( "增加逐仓保证金，持仓方向LONG") or scene.endswith( '增加逐仓保证金，持仓方向SHORT') or \
                scene.endswith( "减少逐仓保证金，持仓方向LONG") or scene.endswith( '减少逐仓保证金，持仓方向SHORT')\
                    or scene.endswith( "增加数量等于账户余额") or scene.endswith( '减少后保证金等于初始保证金') :
            if scene.endswith('增加逐仓保证金，持仓方向LONG'):
                # 初始化 仓位配置
&gt;               set_up_position(symbol="dao_usdt")

test_cases/contract/client/position/test_adjust_margin.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/set_up_balance_and_position.py:58: in set_up_position
    res2 = order_request.create(parm=user2_parm, test_user="test_user2")
operation/contract/client/order/order_request.py:55: in create
    res = xtthanos_trade_http.create(headers=header, params=parm)
api/thanos_http.py:190: in create
    return requests(create.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin" name="test_adjust_margin[main-增加逐仓保证金，持仓方向LONG-20-LONG-dao_usdt-ADD-success-0-1]" time="2.064"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x11135f8e0&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x110ee5640&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x11135f880&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin object at 0x1115c5190&gt;
scene = 'main-增加逐仓保证金，持仓方向LONG', margin = 20, positionSide = 'LONG'
symbol = 'dao_usdt', type = 'ADD', except_result = 'success'
except_returnCode = 0, except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,margin,positionSide,symbol,type,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_margin"])
    def test_adjust_margin(self,scene,margin,positionSide,symbol,type,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{margin}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
        # 调用获取用户信息的接口，得到accountId
        account_id = get_account_info().response.get("result").get("accountId")
    
        # 获取当前symbol 的symbolId
        logger.info("当前用户 accountId 是{}".format(account_id))
        args = {
            "col": "position",
        }
        if scene.endswith( "增加逐仓保证金，持仓方向LONG") or scene.endswith( '增加逐仓保证金，持仓方向SHORT') or \
                scene.endswith( "减少逐仓保证金，持仓方向LONG") or scene.endswith( '减少逐仓保证金，持仓方向SHORT')\
                    or scene.endswith( "增加数量等于账户余额") or scene.endswith( '减少后保证金等于初始保证金') :
            if scene.endswith('增加逐仓保证金，持仓方向LONG'):
                # 初始化 仓位配置
&gt;               set_up_position(symbol="dao_usdt")

test_cases/contract/client/position/test_adjust_margin.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/set_up_balance_and_position.py:66: in set_up_position
    order_request.create(parm=user1_parm, test_user="test_user")
operation/contract/client/order/order_request.py:55: in create
    res = xtthanos_trade_http.create(headers=header, params=parm)
api/thanos_http.py:190: in create
    return requests(create.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin" name="test_adjust_margin[main-增加逐仓保证金，持仓方向SHORT-20-SHORT-dao_usdt-ADD-success-0-0]" time="10.939"><failure message="AssertionError: assert 20.0 == 25.346&#10; +  where 20.0 = round(20.0, 3)&#10; +    where 20.0 = float(Decimal('2E+1'))&#10; +      where Decimal('2E+1') = Decimal('2E+1')&#10; +        where '2E+1' = str(Decimal128('2E+1'))&#10; +          where Decimal128('2E+1') = &lt;built-in method get of dict object at 0x110c52680&gt;('isolatedMargin')&#10; +            where &lt;built-in method get of dict object at 0x110c52680&gt; = {'_id': ObjectId('622bfe752accaf6491750592'), 'accountId': 182, 'autoMargin': False, 'closeOrderSize': Decimal128('0'), ...}.get&#10; +  and   25.346 = round((20.0 + 5.34606878), 3)&#10; +    where 20.0 = float(Decimal('20'))&#10; +      where Decimal('20') = Decimal(20)&#10; +    and   5.34606878 = float(Decimal('5.34606878'))&#10; +      where Decimal('5.34606878') = Decimal('5.34606878')&#10; +        where '5.34606878' = str(Decimal128('5.34606878'))&#10; +          where Decimal128('5.34606878') = &lt;built-in method get of dict object at 0x111405b40&gt;('isolatedMargin')&#10; +            where &lt;built-in method get of dict object at 0x111405b40&gt; = {'_id': ObjectId('622bfe752accaf6491750592'), 'accountId': 182, 'autoMargin': False, 'closeOrderSize': Decimal128('0'), ...}.get">self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin object at 0x1112566a0&gt;
scene = 'main-增加逐仓保证金，持仓方向SHORT', margin = 20, positionSide = 'LONG'
symbol = 'dao_usdt', type = 'ADD', except_result = 'success'
except_returnCode = 0, except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,margin,positionSide,symbol,type,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_margin"])
    def test_adjust_margin(self,scene,margin,positionSide,symbol,type,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{margin}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
        # 调用获取用户信息的接口，得到accountId
        account_id = get_account_info().response.get("result").get("accountId")
    
        # 获取当前symbol 的symbolId
        logger.info("当前用户 accountId 是{}".format(account_id))
        args = {
            "col": "position",
        }
        if scene.endswith( "增加逐仓保证金，持仓方向LONG") or scene.endswith( '增加逐仓保证金，持仓方向SHORT') or \
                scene.endswith( "减少逐仓保证金，持仓方向LONG") or scene.endswith( '减少逐仓保证金，持仓方向SHORT')\
                    or scene.endswith( "增加数量等于账户余额") or scene.endswith( '减少后保证金等于初始保证金') :
            if scene.endswith('增加逐仓保证金，持仓方向LONG'):
                # 初始化 仓位配置
                set_up_position(symbol="dao_usdt")
                set_up_balance()
            # 根据 symbol 获取 symbolId
            symbol_id = s.query.filter(s.symbol == symbol).first().id
            #   根据 accountId 在mongo找到一条position(持仓)信息
            res = MongoDb(args).find({"accountId": account_id,'symbolId':symbol_id})
            position_list = get_position(symbol).response["result"]
            logger.info("当前仓位信息{}".format(position_list))
            for symbol_res in res:
                # entryPrice= 0 是垃圾数据
                if str(symbol_res.get('entryPrice')) != '0':
                    if symbol_res is not None:
                        if symbol_res.get('positionSide') == 2:
                            positionSide = 'SHORT'
                        if symbol_res.get('positionSide') == 1:
                            positionSide = 'LONG'
                        if symbol_res.get('positionSide') == 0:
                            positionSide = 'BOTH'
                        # 数据库获取当前持仓的交易对
                        symbol = s.query.filter(s.id == int(symbol_res.get("symbolId"))).first().symbol
    
                        logger.info("当前用户持仓信息中的交易对是:{} 持仓方向:{} 调整方向:{} 数量:{}".format(symbol,positionSide,type,margin))
                        logger.info("修改保证金之前的仓位保证金是: {}".format(symbol_res.get('isolatedMargin')))
                        if scene.endswith( "增加数量等于账户余额"):
                            res = get_balance_coin(coin='usdt').response
                            # 可增加最大保证金为
                            margin = float(str(round(float(str(res.get('result').get('availableBalance'))),4))[:-1])
                            logger.info("当前可增加最大保证金是 {}".format(margin))
                        if scene.endswith('减少后保证金等于初始保证金'):
                            margin_results = margin_max_and_min(account_id, symbol, 1)
                            logger.info("做多的仓位 保证金信息 {}".format(margin_results))
                            margin = float(str(round(float(Decimal(str(symbol_res.get('isolatedMargin')))) \
                                    - float(Decimal(str(margin_results.get("start_margin")))),3))[:-1])
                        result = adjust_margin(margin, positionSide, symbol, type)
                        # {'max_margin': '2215.77564746', 'min_margin': 2215.77564746 ,'start_margin' : '3.6844'  }
                        # 更改之后的数据查询
                        time.sleep(3)
                        symbolId = s.query.filter(s.symbol == symbol).first().id
                        re = MongoDb(args).find_one({"accountId": account_id, 'symbolId': symbolId,'positionSide':symbol_res.get('positionSide')})
                        logger.info("修改保证金之后的仓位保证金是: {}".format(re.get('isolatedMargin')))
                        if type == "ADD":
                            # 修改保证金之后的与之前的相等 当前对比 选择 保留三位有效小数之后进行对比
&gt;                           assert round(float(Decimal(str(re.get('isolatedMargin')))),3) ==\
                                   round(float(Decimal(margin)) +float(Decimal(str(symbol_res.get('isolatedMargin')))),3)
E                           AssertionError: assert 20.0 == 25.346
E                            +  where 20.0 = round(20.0, 3)
E                            +    where 20.0 = float(Decimal('2E+1'))
E                            +      where Decimal('2E+1') = Decimal('2E+1')
E                            +        where '2E+1' = str(Decimal128('2E+1'))
E                            +          where Decimal128('2E+1') = &lt;built-in method get of dict object at 0x110c52680&gt;('isolatedMargin')
E                            +            where &lt;built-in method get of dict object at 0x110c52680&gt; = {'_id': ObjectId('622bfe752accaf6491750592'), 'accountId': 182, 'autoMargin': False, 'closeOrderSize': Decimal128('0'), ...}.get
E                            +  and   25.346 = round((20.0 + 5.34606878), 3)
E                            +    where 20.0 = float(Decimal('20'))
E                            +      where Decimal('20') = Decimal(20)
E                            +    and   5.34606878 = float(Decimal('5.34606878'))
E                            +      where Decimal('5.34606878') = Decimal('5.34606878')
E                            +        where '5.34606878' = str(Decimal128('5.34606878'))
E                            +          where Decimal128('5.34606878') = &lt;built-in method get of dict object at 0x111405b40&gt;('isolatedMargin')
E                            +            where &lt;built-in method get of dict object at 0x111405b40&gt; = {'_id': ObjectId('622bfe752accaf6491750592'), 'accountId': 182, 'autoMargin': False, 'closeOrderSize': Decimal128('0'), ...}.get

test_cases/contract/client/position/test_adjust_margin.py:89: AssertionError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin" name="test_adjust_margin[main-增加逐仓保证金，持仓方向SHORT-20-SHORT-dao_usdt-ADD-success-0-1]" time="3.634"><failure message="requests.exceptions.ChunkedEncodingError: (&quot;Connection broken: InvalidChunkLength(got length b'', 0 bytes read)&quot;, InvalidChunkLength(got length b'', 0 bytes read))">self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
&gt;           self.chunk_left = int(line, 16)
E           ValueError: invalid literal for int() with base 16: b''

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:697: ValueError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
&gt;               yield

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
&gt;               self._update_chunk_length()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b";", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
&gt;           raise InvalidChunkLength(self, line)
E           urllib3.exceptions.InvalidChunkLength: InvalidChunkLength(got length b'', 0 bytes read)

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:701: InvalidChunkLength

During handling of the above exception, another exception occurred:

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
&gt;               for chunk in self.raw.stream(chunk_size, decode_content=True):

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;, amt = 10240
decode_content = True

    def stream(self, amt=2 ** 16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.
    
        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        if self.chunked and self.supports_chunked_reads():
&gt;           for line in self.read_chunked(amt, decode_content=decode_content):

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;, amt = 10240
decode_content = True

    def read_chunked(self, amt=None, decode_content=None):
        """
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.
    
        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                "Response is not chunked. "
                "Header 'transfer-encoding: chunked' is missing."
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                "Body should be http.client.HTTPResponse like. "
                "It should have have an fp attribute which returns raw chunks."
            )
    
        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return
    
            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return
    
            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded
    
            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded
    
            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b"\r\n":
                    break
    
            # We read everything; close the "file".
            if self._original_response:
&gt;               self._original_response.close()

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x1112dbe20&gt;
type = &lt;class 'urllib3.exceptions.InvalidChunkLength'&gt;
value = InvalidChunkLength(got length b'', 0 bytes read)
traceback = &lt;traceback object at 0x10fe7f0c0&gt;

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
&gt;               self.gen.throw(type, value, traceback)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/contextlib.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.response.HTTPResponse object at 0x1112db2b0&gt;

    @contextmanager
    def _error_catcher(self):
        """
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.
    
        On exit, release the connection back to the pool.
        """
        clean_exit = False
    
        try:
            try:
                yield
    
            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if "read operation timed out" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)
    
                raise ReadTimeoutError(self._pool, None, "Read timed out.")
    
            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
&gt;               raise ProtocolError("Connection broken: %r" % e, e)
E               urllib3.exceptions.ProtocolError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/urllib3/response.py:455: ProtocolError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin object at 0x11127c670&gt;
scene = 'main-增加逐仓保证金，持仓方向SHORT', margin = 20, positionSide = 'SHORT'
symbol = 'dao_usdt', type = 'ADD', except_result = 'success'
except_returnCode = 0, except_msg = ''

    @pytest.mark.single
    # @pytest.mark.usefixtures("step_first")
    @pytest.mark.parametrize("scene,margin,positionSide,symbol,type,except_result, except_returnCode, except_msg",
                             api_position_data["adjust_margin"])
    def test_adjust_margin(self,scene,margin,positionSide,symbol,type,except_result,except_returnCode, except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{margin}-{positionSide}-{symbol}-{except_result}-{except_returnCode}-"{except_msg}"')
        # 调用获取用户信息的接口，得到accountId
        account_id = get_account_info().response.get("result").get("accountId")
    
        # 获取当前symbol 的symbolId
        logger.info("当前用户 accountId 是{}".format(account_id))
        args = {
            "col": "position",
        }
        if scene.endswith( "增加逐仓保证金，持仓方向LONG") or scene.endswith( '增加逐仓保证金，持仓方向SHORT') or \
                scene.endswith( "减少逐仓保证金，持仓方向LONG") or scene.endswith( '减少逐仓保证金，持仓方向SHORT')\
                    or scene.endswith( "增加数量等于账户余额") or scene.endswith( '减少后保证金等于初始保证金') :
            if scene.endswith('增加逐仓保证金，持仓方向LONG'):
                # 初始化 仓位配置
                set_up_position(symbol="dao_usdt")
                set_up_balance()
            # 根据 symbol 获取 symbolId
            symbol_id = s.query.filter(s.symbol == symbol).first().id
            #   根据 accountId 在mongo找到一条position(持仓)信息
            res = MongoDb(args).find({"accountId": account_id,'symbolId':symbol_id})
            position_list = get_position(symbol).response["result"]
            logger.info("当前仓位信息{}".format(position_list))
            for symbol_res in res:
                # entryPrice= 0 是垃圾数据
                if str(symbol_res.get('entryPrice')) != '0':
                    if symbol_res is not None:
                        if symbol_res.get('positionSide') == 2:
                            positionSide = 'SHORT'
                        if symbol_res.get('positionSide') == 1:
                            positionSide = 'LONG'
                        if symbol_res.get('positionSide') == 0:
                            positionSide = 'BOTH'
                        # 数据库获取当前持仓的交易对
                        symbol = s.query.filter(s.id == int(symbol_res.get("symbolId"))).first().symbol
    
                        logger.info("当前用户持仓信息中的交易对是:{} 持仓方向:{} 调整方向:{} 数量:{}".format(symbol,positionSide,type,margin))
                        logger.info("修改保证金之前的仓位保证金是: {}".format(symbol_res.get('isolatedMargin')))
                        if scene.endswith( "增加数量等于账户余额"):
                            res = get_balance_coin(coin='usdt').response
                            # 可增加最大保证金为
                            margin = float(str(round(float(str(res.get('result').get('availableBalance'))),4))[:-1])
                            logger.info("当前可增加最大保证金是 {}".format(margin))
                        if scene.endswith('减少后保证金等于初始保证金'):
                            margin_results = margin_max_and_min(account_id, symbol, 1)
                            logger.info("做多的仓位 保证金信息 {}".format(margin_results))
                            margin = float(str(round(float(Decimal(str(symbol_res.get('isolatedMargin')))) \
                                    - float(Decimal(str(margin_results.get("start_margin")))),3))[:-1])
                        result = adjust_margin(margin, positionSide, symbol, type)
                        # {'max_margin': '2215.77564746', 'min_margin': 2215.77564746 ,'start_margin' : '3.6844'  }
                        # 更改之后的数据查询
                        time.sleep(3)
                        symbolId = s.query.filter(s.symbol == symbol).first().id
                        re = MongoDb(args).find_one({"accountId": account_id, 'symbolId': symbolId,'positionSide':symbol_res.get('positionSide')})
                        logger.info("修改保证金之后的仓位保证金是: {}".format(re.get('isolatedMargin')))
                        if type == "ADD":
                            # 修改保证金之后的与之前的相等 当前对比 选择 保留三位有效小数之后进行对比
                            assert round(float(Decimal(str(re.get('isolatedMargin')))),3) ==\
                                   round(float(Decimal(margin)) +float(Decimal(str(symbol_res.get('isolatedMargin')))),3)
                        else:
                            # 修改保证金之后的与之前的相等 当前对比 选择 保留三位有效小数之后进行对比
                            assert round(float(Decimal(str(re.get('isolatedMargin')))), 3) == \
                                   round(float(Decimal(str(symbol_res.get('isolatedMargin')))) - float(Decimal(margin)) ,
                                         3)
                        assert result.status_code == 200
                        assert except_result == result.response["msgInfo"]
                        assert except_returnCode == result.response["returnCode"]
                        if except_returnCode == 0:
                            assert except_msg in str(result.response["result"])
                        else:
                            assert except_msg in result.response["error"]["msg"]
                        return
    
&gt;       result = adjust_margin(margin,positionSide,symbol,type)

test_cases/contract/client/position/test_adjust_margin.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
operation/contract/client/position/adjust_margin.py:31: in adjust_margin
    res = xtthanos_user_http.adjust_margin(headers=headers, params=params)
api/thanos_http.py:49: in adjust_margin
    return requests(position_margin.get('path'), **kwargs)
api/http_api.py:19: in post
    return self.request(url, "POST", data, json, **kwargs)
api/http_api.py:41: in request
    return requests.post(url, data, json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:119: in post
    return request('post', url, data=data, json=json, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../Library/Python/3.8/lib/python/site-packages/requests/sessions.py:697: in send
    r.content
../../Library/Python/3.8/lib/python/site-packages/requests/models.py:831: in content
    self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, 'stream'):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
&gt;               raise ChunkedEncodingError(e)
E               requests.exceptions.ChunkedEncodingError: ("Connection broken: InvalidChunkLength(got length b'', 0 bytes read)", InvalidChunkLength(got length b'', 0 bytes read))

../../Library/Python/3.8/lib/python/site-packages/requests/models.py:756: ChunkedEncodingError</failure></testcase><testcase classname="test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin" name="test_adjust_margin[main-减少逐仓保证金，持仓方向LONG-20-LONG-dao_usdt-SUB-success-0-]" time="2.584" /><testcase classname="test_cases.contract.client.position.test_adjust_margin.Test_adjust_margin" name="test_adjust_margin[main-减少逐仓保证金，持仓方向SHORT-20-SHORT-dao_usdt-SUB-success-0-]" time="3.236" /><testcase classname="test_cases.contract.client.position.test_get_adl.Test_get_adl" name="test_get_adl[main-正常查询-success-0-]" time="0.243" /><testcase classname="test_cases.contract.client.position.test_get_position.Test_get_position" name="test_get_position[main-正常查询-dao_usdt-success-0-]" time="2.317" /><testcase classname="test_cases.contract.client.position.test_position_close_all.Test_position_close_all" name="test_position_close_all[main-该交易对有仓位-dao_usdt-success-0-]" time="0.377" /><testcase classname="test_cases.contract.client.quote.test_deal.TestDeal" name="test_deal_success[test_data0]" time="76.769"><failure message="redis.exceptions.ConnectionError: Error 60 connecting to 13.214.89.218:6642. Operation timed out.">self = SSLConnection&lt;host=13.214.89.218,port=6642,db=0&gt;

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
&gt;           sock = self._connect()

../../Library/Python/3.8/lib/python/site-packages/redis/connection.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SSLConnection&lt;host=13.214.89.218,port=6642,db=0&gt;

    def _connect(self):
        "Wrap the socket with SSL support"
&gt;       sock = super(SSLConnection, self)._connect()

../../Library/Python/3.8/lib/python/site-packages/redis/connection.py:851: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SSLConnection&lt;host=13.214.89.218,port=6642,db=0&gt;

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,
                                      socket.SOCK_STREAM):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in iteritems(self.socket_keepalive_options):
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
                sock.connect(socket_address)
    
                # set the socket_timeout now that we're connected
                sock.settimeout(self.socket_timeout)
                return sock
    
            except socket.error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
&gt;           raise err

../../Library/Python/3.8/lib/python/site-packages/redis/connection.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SSLConnection&lt;host=13.214.89.218,port=6642,db=0&gt;

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,
                                      socket.SOCK_STREAM):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in iteritems(self.socket_keepalive_options):
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
&gt;               sock.connect(socket_address)
E               TimeoutError: [Errno 60] Operation timed out

../../Library/Python/3.8/lib/python/site-packages/redis/connection.py:603: TimeoutError

During handling of the above exception, another exception occurred:

self = &lt;thanos_test.test_cases.contract.client.quote.test_deal.TestDeal object at 0x11133e2b0&gt;
test_data = {'test_deal_failed': {}, 'test_deal_success': {'test_by_symbol': {'expect_result': {'msgInfo': 'success'}, 'name': 'ma...'expect_result': {'msgInfo': 'success'}, 'name': 'main-正确通过条数和交易对获取', 'parameter': {'num': 10, 'symbol': 'dao_usdt'}}}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("test_deal_success") == {} else [test_data])
    def test_deal_success(self,test_data):
        cases_data = test_data["test_deal_success"]
        for value in cases_data.values():
            name, parameter = value["name"], value["parameter"]
            expected_result = value["expect_result"]
            res = self.quote_request.deal(param=parameter)
            logger.info(f'获取最新成交价格接口返回：{name}的返回结果---》{res}')
&gt;           redis_res = redis_cli.get_symbol_deal(parameter.get("symbol"), 0, parameter.get("num"))

test_cases/contract/client/quote/test_deal.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/redis_operate.py:43: in get_symbol_deal
    return self.conn.zrange(key,min,max)
../../Library/Python/3.8/lib/python/site-packages/redis/client.py:2801: in zrange
    return self.execute_command(*pieces, **options)
../../Library/Python/3.8/lib/python/site-packages/redis/client.py:898: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
../../Library/Python/3.8/lib/python/site-packages/redis/connection.py:1192: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SSLConnection&lt;host=13.214.89.218,port=6642,db=0&gt;

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except socket.error as e:
&gt;           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 60 connecting to 13.214.89.218:6642. Operation timed out.

../../Library/Python/3.8/lib/python/site-packages/redis/connection.py:563: ConnectionError</failure></testcase><testcase classname="test_cases.contract.client.quote.test_deal.TestDeal" name="test_by_symbol[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_by_symbol at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_deal.py:33">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_deal.py:34: got empty parameter set ['test_data'], function test_by_symbol at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_deal.py:33</skipped></testcase><testcase classname="test_cases.contract.client.quote.test_depth.TestDepth" name="test_correct[test_data0]" time="1.015" /><testcase classname="test_cases.contract.client.quote.test_depth.TestDepth" name="test_unsuccess[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_depth.py:29">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_depth.py:30: got empty parameter set ['test_data'], function test_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_depth.py:29</skipped></testcase><testcase classname="test_cases.contract.client.quote.test_funding_rate.TestFundingRate" name="test_success[test_data0]" time="0.523" /><testcase classname="test_cases.contract.client.quote.test_funding_rate.TestFundingRate" name="test_unsuccess[test_data0]" time="0.117" /><testcase classname="test_cases.contract.client.quote.test_funding_rate_record.TestFundingRateRecord" name="test_success[test_data0]" time="11.813" /><testcase classname="test_cases.contract.client.quote.test_index_price.TestIndexPrice" name="test_success[test_data0]" time="0.114" /><testcase classname="test_cases.contract.client.quote.test_index_price.TestIndexPrice" name="test_unsuccess[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_index_price.py:32">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_index_price.py:33: got empty parameter set ['test_data'], function test_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_index_price.py:32</skipped></testcase><testcase classname="test_cases.contract.client.quote.test_kline.TestKline" name="test_success[test_data0]" time="0.002"><failure message="AttributeError: 'thanos_market_http' object has no attribute 'kline'">self = &lt;thanos_test.test_cases.contract.client.quote.test_kline.TestKline object at 0x110f972e0&gt;
test_data = {'test_success': {'all_parm': {'expected_result': {'msgInfo': 'success'}, 'name': 'main-所有参数正确输入', 'parameter': {'endT...正确输入时间间隔和交易对', 'parameter': {'endTime': 1647240077842, 'interval': '1w', 'symbol': 'dao_usdt'}}}, 'test_unsuccess': {}}

    @pytest.mark.parametrize("test_data", [] if test_data.get("test_success") == {} else [test_data])
    def test_success(self, test_data):
        qoute_request = self.qoute_request
        cases_data = test_data["test_success"]
        for case_data in cases_data.values():
            parameter, case_name, expected_result = case_data["parameter"], case_data["name"], case_data[
                "expected_result"]
            time_now = time.time()
            parameter["endTime"] = int(round(time_now * 1000))
&gt;           res = qoute_request.kline(parameter)

test_cases/contract/client/quote/test_kline.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;operation.contract.client.quote.qoute_class.Qoute object at 0x110cc30d0&gt;
param = {'endTime': 1647240077842, 'interval': '1w', 'symbol': 'dao_usdt'}
test_user = 'test_user'

    def kline(self, param=None, test_user="test_user"):
        if not param:
            param = {"symbol": "dao_usdt", "interval": "1h", "limit": 10}
        path, method = self.request_data["kline"]["route"] + self.request_data["kline"]["path"], \
                       self.request_data["kline"]["method"]
        header = generate_auth_info(path=path, method=method, params=param, test_user=test_user)
&gt;       res = xtthanos_market_http.kline(headers=header, params=param)
E       AttributeError: 'thanos_market_http' object has no attribute 'kline'

operation/contract/client/quote/qoute_class.py:73: AttributeError</failure></testcase><testcase classname="test_cases.contract.client.quote.test_kline.TestKline" name="test_unsuccess[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_kline.py:70">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_kline.py:71: got empty parameter set ['test_data'], function test_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_kline.py:70</skipped></testcase><testcase classname="test_cases.contract.client.quote.test_mark_price.TestKline" name="test_success[test_data0]" time="0.483" /><testcase classname="test_cases.contract.client.quote.test_mark_price.TestKline" name="test_unsucces[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_unsucces at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_mark_price.py:30">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_mark_price.py:31: got empty parameter set ['test_data'], function test_unsucces at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_mark_price.py:30</skipped></testcase><testcase classname="test_cases.contract.client.quote.test_qoute_agg_ticker.Test_qoute_agg_ticker" name="test_qoute_agg_ticker[main-正确的交易对-dao_usdt-success-0-success]" time="0.137"><failure message="assert 'success' in &quot;{'t': 1647070120601, 's': 'dao_usdt', 'c': '2.269', 'h': '2.338', 'l': '2.269', 'a': '520', 'v': '1200', 'o': '2.334', 'r': '-0.0278', 'i': '2.27323', 'm': '6.842', 'bp': '5', 'ap': '2.269'}&quot;&#10; +  where &quot;{'t': 1647070120601, 's': 'dao_usdt', 'c': '2.269', 'h': '2.338', 'l': '2.269', 'a': '520', 'v': '1200', 'o': '2.334', 'r': '-0.0278', 'i': '2.27323', 'm': '6.842', 'bp': '5', 'ap': '2.269'}&quot; = str({'a': '520', 'ap': '2.269', 'bp': '5', 'c': '2.269', ...})">self = &lt;thanos_test.test_cases.contract.client.quote.test_qoute_agg_ticker.Test_qoute_agg_ticker object at 0x110f587c0&gt;
scene = 'main-正确的交易对', symbol = 'dao_usdt', except_result = 'success'
except_code = 0, except_msg = 'success'

    @pytest.mark.single
    @pytest.mark.parametrize("scene,symbol,except_result,except_code,except_msg",
                             api_quote_data["qoute_agg_ticker"])
    def test_qoute_agg_ticker(self,scene,symbol,except_result,except_code,except_msg):
        # logger.info("*************** 开始执行用例 ***************")
        logger.info(f'场景【{scene}】信息：{except_result}-{except_code}-"{except_msg}"')
        result = qoute_agg_ticker(symbol)
        assert except_result == result.response["msgInfo"]
        assert except_code == result.response["returnCode"]
        if except_code == 0:
&gt;           assert except_msg in str(result.response["result"])
E           assert 'success' in "{'t': 1647070120601, 's': 'dao_usdt', 'c': '2.269', 'h': '2.338', 'l': '2.269', 'a': '520', 'v': '1200', 'o': '2.334', 'r': '-0.0278', 'i': '2.27323', 'm': '6.842', 'bp': '5', 'ap': '2.269'}"
E            +  where "{'t': 1647070120601, 's': 'dao_usdt', 'c': '2.269', 'h': '2.338', 'l': '2.269', 'a': '520', 'v': '1200', 'o': '2.334', 'r': '-0.0278', 'i': '2.27323', 'm': '6.842', 'bp': '5', 'ap': '2.269'}" = str({'a': '520', 'ap': '2.269', 'bp': '5', 'c': '2.269', ...})

test_cases/contract/client/quote/test_qoute_agg_ticker.py:33: AssertionError</failure></testcase><testcase classname="test_cases.contract.client.quote.test_qoute_agg_tickers.Test_qoute_agg_tickers" name="test_qoute_agg_tickers[main-获取全交易对的ticker信息-success-0-success]" time="0.113" /><testcase classname="test_cases.contract.client.quote.test_ticker.TestTicker" name="test_ticker_success[test_data0]" time="0.673" /><testcase classname="test_cases.contract.client.quote.test_ticker.TestTicker" name="test_ticker_unsuccess[test_data0]" time="0.001"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_ticker_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_ticker.py:54">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_ticker.py:55: got empty parameter set ['test_data'], function test_ticker_unsuccess at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_ticker.py:54</skipped></testcase><testcase classname="test_cases.contract.client.quote.test_ticker.TestTicker" name="test_tickers[test_data0]" time="0.000"><skipped type="pytest.skip" message="got empty parameter set ['test_data'], function test_tickers at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_ticker.py:64">/Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_ticker.py:65: got empty parameter set ['test_data'], function test_tickers at /Users/xushuai/Documents/thanos_test/test_cases/contract/client/quote/test_ticker.py:64</skipped></testcase><testcase classname="test_cases.contract.client.symbol_info.test_get_symbol_coins.Test_get_symbol_coins" name="test_get_symbol_coins[main-正常查询-success-0-]" time="0.634" /><testcase classname="test_cases.contract.client.symbol_info.test_get_symbol_info.Test_get_symbol_info" name="test_get_symbol_info[main-交易对存在-dao_usdt-success-0-]" time="0.195" /><testcase classname="test_cases.contract.client.symbol_info.test_get_symbol_list_info.Test_get_symbol_list_info" name="test_get_symbol_list_info[main-正常查询-success-0-]" time="0.313" /></testsuite></testsuites>